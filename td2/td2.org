# -*- coding: utf-8 -*-

#+TITLE: Concepts de base du langage =Python=
#+AUTHOR: Roland Donat
#+EMAIL: roland.donat@univ-ubs.fr
# #+DATE: 

# ==============================================
# Document Configuration
# ======================
# Orgmode
:CONFIG:
#+LANGUAGE: fr
#+OPTIONS: H:3 num:t toc:nil \n:nil @:t ::t |:t ^:{} f:t TeX:t author:t d:nil timestamp:nil
#+OPTIONS: html-postamble:nil
#+STARTUP: content 
#+STARTUP: hidestars
#+DRAWERS: CONFIG OPTIONS CACHE MACROS
#+TODO: TODO(t) INPROGRESS(p) | DONE(d)
#+BIND: org-latex-table-scientific-notation "{%s}E{%s}"
:END:

# LaTeX
# -----
# Class parameters
:CONFIG:
#+LaTeX_CLASS: ubs-note
#+LaTeX_CLASS_OPTIONS: [a4paper,twoside,11pt]
#+LATEX_HEADER: \thelang{FR}
#+LATEX_HEADER: \thesubtitle{}
#+LATEX_HEADER: \institution{IUT Vannes}
#+LATEX_HEADER: \course{Intoduction Ã  \texttt{Python}}
#+LATEX_HEADER: \cursus{Licences professionnelles SDM/SIS}
#+LATEX_HEADER: \version{1.0}
:END:
# Packages
:CONFIG:
#+LATEX_HEADER: \usepackage[french]{babel}
#+LATEX_HEADER: \usepackage{graphicx}
#+LATEX_HEADER: \usepackage{amssymb}
#+LATEX_HEADER: \usepackage{amsmath}
#+LATEX_HEADER: \usepackage{amsfonts}
#+LATEX_HEADER: \usepackage{xcolor}
#+LATEX_HEADER: \usepackage{verbatim}
#+LATEX_HEADER: \usepackage{tabularx}
#+LATEX_HEADER: \usepackage{float}
#+LATEX_HEADER: \usepackage{lmodern}
#+LATEX_HEADER: \usepackage{natbib}
#+LATEX_HEADER: \usepackage{subfig}
#+LATEX_HEADER: \usepackage{booktabs}
#+LATEX_HEADER: \usepackage{minted}
:END:
# Layout
:CONFIG:
# Figures path
#+LATEX_HEADER: % Graphics path
#+LATEX_HEADER: \graphicspath{ 
#+LATEX_HEADER:   {./fig/}
#+LATEX_HEADER: }

# Colors
#+LATEX_HEADER: \definecolor{almostwhite}        {rgb}{0.85,0.85,0.85}

# Minted
# To control spaces between minted block
#+LATEX_HEADER: \AtBeginEnvironment{snugshade*}{\vspace{-1.25\FrameSep}}
#+LATEX_HEADER: \AfterEndEnvironment{snugshade*}{\vspace{-2\FrameSep}}
# #+LATEX_HEADER: \usemintedstyle{monokai}
# #+LATEX_HEADER: \renewcommand{\theFancyVerbLine}{\sffamily \footnotesize {\color{EMLogoBlue}\oldstylenums{\arabic{FancyVerbLine}}}}

# Captions
#+LATEX_HEADER: \captionsetup[table]{position=bottom,margin=90pt,font=small,labelfont=bf,labelsep=endash,format=plain}
#+LATEX_HEADER: \captionsetup[figure]{position=bottom,margin=90pt,font=small,labelfont=bf,labelsep=endash,format=plain}
#+LATEX_HEADER: \captionsetup[subfloat]{margin=0pt,font=footnotesize}

# Geometry
#+LATEX_HEADER: \usepackage{geometry}
#+LATEX_HEADER: \geometry{
#+LATEX_HEADER: %  nohead,
#+LATEX_HEADER:   top=2.25cm, 
#+LATEX_HEADER:   bottom=2.25cm, 
#+LATEX_HEADER:  left=2.5cm, 
#+LATEX_HEADER:  right=2.5cm}

#+LATEX_HEADER: \usepackage{setspace}
#+LATEX_HEADER: \onehalfspacing
#+LATEX_HEADER: % Supprime l'indentation
#+LATEX_HEADER: \setlength{\parindent}{0pt}
#+LATEX_HEADER: % Espacement entre les paragraphes
#+LATEX_HEADER: \setlength{\parskip}{2ex}

# List layout
#+LATEX_HEADER: \frenchbsetup{ListOldLayout=true} %FBReduceListSpacing=true,CompactItemize=false}

# References
#+LATEX: \renewcommand*{\refname}{}*
:END:
# LaTeX Compilator
:CONFIG:
#+BEGIN_SRC emacs-lisp :results silent :exports none
(setq org-latex-listings 'minted
      org-latex-minted-options nil ;; '(("frame" "lines")))
      org-latex-pdf-process
      '("xelatex -shell-escape -interaction nonstopmode -output-directory %o %f"
        "bibtex %b"
        "xelatex -shell-escape -interaction nonstopmode -output-directory %o %f"
        "xelatex -shell-escape -interaction nonstopmode -output-directory %o %f"))
#+END_SRC
:END:

# HTML
# ----
:CONFIG:
# Org HTML Macros
#+MACRO: NEWLINE @@latex:\\@@ @@html:<br>@@
#+MACRO: HTMLFONTSIZE @@html:<font size="$2">$1</font>@@
#+MACRO: SUBTITLE @@html:<div class="slidesubtitle">$1</div>@@

# HTML options
# ------------
# #+HTML_HEAD: <link rel="stylesheet" type="text/css" href="./css/edgemind.css" />
# #+HTML_HEAD: <link rel="stylesheet" type="text/css" href="./css/ensibs.css" />
# CSS to get the ReadTheDoc style
# #+HTML_HEAD: <link rel="stylesheet" type="text/css" href="https://www.pirilampo.org/styles/readtheorg/css/htmlize.css"/>
# #+HTML_HEAD: <link rel="stylesheet" type="text/css" href="https://www.pirilampo.org/styles/readtheorg/css/readtheorg.css"/>
# #+HTML_HEAD: <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
# #+HTML_HEAD: <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
# #+HTML_HEAD: <script type="text/javascript" src="https://www.pirilampo.org/styles/lib/js/jquery.stickytableheaders.js"></script>
# #+HTML_HEAD: <script type="text/javascript" src="https://www.pirilampo.org/styles/readtheorg/js/readtheorg.js"></script>
:END:

# Publishing
# ----------
:CONFIG:
#+BEGIN_SRC emacs-lisp :results silent :exports none
;; Define some export options here since in org-publish-project-alist some of them are not taken into account
;; e.g. with-toc nil
(defun my-html-export-options (plist backend)
  (cond 
    ((equal backend 'html)
     (plist-put plist :with-toc t)
     (plist-put plist :section-numbers nil)
     (plist-put plist :with-author t)
     (plist-put plist :with-email t)
     (plist-put plist :with-date t)
     ))
  plist)

(setq org-publish-project-alist
      '(
	
        ("main"
         :base-directory "./"
         :include ("rb_mod_stoch.org")
         :publishing-directory "./"
         :recursive nil
         :publishing-function org-html-publish-to-html
         :preparation-function (lambda () (setq org-export-filter-options-functions '(my-html-export-options)))
         :auto-preamble t
         :html-head  "<link rel='stylesheet' type='text/css' href='edgemind.css' />"
         :htmlized-source 
	 :section-numbers nil
         )
        ("td-html"
         :base-directory "./td/"
         :base-extension "org"
         :publishing-directory "./td"
         :recursive t
         :publishing-function org-html-publish-to-html
         :preparation-function (lambda () (setq org-export-filter-options-functions '(my-html-export-options)))
         :auto-preamble t
         :html-head  "<link rel='stylesheet' type='text/css' href='edgemind.css' />"
         :htmlized-source 
         )

	 ;; pdf
        ("td-pdf"
         :base-directory "./td/"
         :base-extension "org"
         :publishing-directory "./td"
         :recursive t
         :publishing-function org-latex-publish-to-pdf
         )

	 ("td-attach"
	 :base-directory "./td/"
	 :base-extension "xdsl\\|txt\\|csv\\|py\\|png"
         :publishing-directory "./td"
	 :recursive t
	 :publishing-function org-publish-attachment
	 )

	 ("cours-attach"
	 :base-directory "./cours/"
	 :base-extension "pdf\\|xdsl\\|txt\\|csv\\|py"
         :publishing-directory "./cours"
	 :recursive t
	 :publishing-function org-publish-attachment
	 )

        ("projet-html"
         :base-directory "./projet/"
         :base-extension "org"
         :publishing-directory "./projet"
         :recursive t
         :publishing-function org-html-publish-to-html
         :preparation-function (lambda () (setq org-export-filter-options-functions '(my-html-export-options)))
         :auto-preamble t
         :html-head  "<link rel='stylesheet' type='text/css' href='edgemind.css' />"
         :htmlized-source 
         )

	 ("projet-attach"
	 :base-directory "./projet/"
	 :base-extension "xdsl\\|txt\\|csv"
         :publishing-directory "./projet"
	 :recursive t
	 :publishing-function org-publish-attachment
	 )

	 ("css"
         :base-directory "./css/"
         :base-extension "css"
         :publishing-directory "./www/css"
         :publishing-function org-publish-attachment)
	 
	 ;("rb_mod_stoch" :components ("main" "td-pdf" "td-html" "td-attach" "cours-attach" "projet-html" "projet-attach" "css"))
	 ;("rb_mod_stoch" :components ("main" "td-pdf" "td-html" "projet-html"))
	 ("rb_mod_stoch" :components ("main"))

      ))
#+END_SRC
:END:

# ==============================================
# Document starts here
# ====================

#+ATTR_LATEX: :width 0.9\textwidth
[[./fig/python_comics.png]]

#+LATEX: \clearpage

* Configuration                                                    :noexport:
# Latex command to work with minted
:CACHE:
#+HEADER: :eval yes
#+HEADER: :results silent
#+HEADER: :exports none
#+BEGIN_SRC emacs-lisp 
(setq org-latex-listings 'minted
      org-latex-minted-options nil ;; '(("frame" "lines")))
      org-latex-pdf-process
      '("xelatex -shell-escape -interaction nonstopmode -output-directory %o %f"
        "bibtex %b"
        "xelatex -shell-escape -interaction nonstopmode -output-directory %o %f"
        "xelatex -shell-escape -interaction nonstopmode -output-directory %o %f"))
#+END_SRC
:END:


# Publishing configuration
# ------------------------
:CACHE:
#+HEADER: :eval yes
#+HEADER: :results silent
#+HEADER: :exports none
#+BEGIN_SRC emacs-lisp 
;; Define some export options here since in org-publish-project-alist some of them are not taken into account
;; e.g. with-toc nil
(defun my-html-export-options (plist backend)
  (cond 
    ((equal backend 'html)
     (plist-put plist :with-toc t)
     (plist-put plist :section-numbers nil)
     (plist-put plist :with-author t)
     (plist-put plist :with-email t)
     (plist-put plist :with-date t)
     ))
  plist)

(setq org-publish-project-alist
      '(
	
        ("main"
         :base-directory "./"
         :include ("rb_mod_stoch.org")
         :publishing-directory "./"
         :recursive nil
         :publishing-function org-html-publish-to-html
         :preparation-function (lambda () (setq org-export-filter-options-functions '(my-html-export-options)))
         :auto-preamble t
         :html-head  "<link rel='stylesheet' type='text/css' href='edgemind.css' />"
         :htmlized-source 
	 :section-numbers nil
         )
        ("td-html"
         :base-directory "./td/"
         :base-extension "org"
         :publishing-directory "./td"
         :recursive t
         :publishing-function org-html-publish-to-html
         :preparation-function (lambda () (setq org-export-filter-options-functions '(my-html-export-options)))
         :auto-preamble t
         :html-head  "<link rel='stylesheet' type='text/css' href='edgemind.css' />"
         :htmlized-source 
         )

	 ;; pdf
        ("td-pdf"
         :base-directory "./td/"
         :base-extension "org"
         :publishing-directory "./td"
         :recursive t
         :publishing-function org-latex-publish-to-pdf
         )

	 ("td-attach"
	 :base-directory "./td/"
	 :base-extension "xdsl\\|txt\\|csv\\|py\\|png"
         :publishing-directory "./td"
	 :recursive t
	 :publishing-function org-publish-attachment
	 )

	 ("cours-attach"
	 :base-directory "./cours/"
	 :base-extension "pdf\\|xdsl\\|txt\\|csv\\|py"
         :publishing-directory "./cours"
	 :recursive t
	 :publishing-function org-publish-attachment
	 )

        ("projet-html"
         :base-directory "./projet/"
         :base-extension "org"
         :publishing-directory "./projet"
         :recursive t
         :publishing-function org-html-publish-to-html
         :preparation-function (lambda () (setq org-export-filter-options-functions '(my-html-export-options)))
         :auto-preamble t
         :html-head  "<link rel='stylesheet' type='text/css' href='edgemind.css' />"
         :htmlized-source 
         )

	 ("projet-attach"
	 :base-directory "./projet/"
	 :base-extension "xdsl\\|txt\\|csv"
         :publishing-directory "./projet"
	 :recursive t
	 :publishing-function org-publish-attachment
	 )

	 ("css"
         :base-directory "./css/"
         :base-extension "css"
         :publishing-directory "./www/css"
         :publishing-function org-publish-attachment)
	 
	 ;("rb_mod_stoch" :components ("main" "td-pdf" "td-html" "td-attach" "cours-attach" "projet-html" "projet-attach" "css"))
	 ;("rb_mod_stoch" :components ("main" "td-pdf" "td-html" "projet-html"))
	 ("rb_mod_stoch" :components ("main"))

      ))
#+END_SRC
:END:


* Objectif

Ce TD a pour objectif de vous donner un aperÃ§u des concepts de base du langage =Python=. Nous
abordons ainsi les notions de type, opÃ©rateur mathÃ©matique et variable. Nous terminons avec une
section dÃ©diÃ©e Ã  la manipulation des chaÃ®nes de caractÃ¨res.

Pour rÃ©aliser ce TD, crÃ©ez un /notebook/ =Jupyter= dans le lequel vous allez exÃ©cuter votre code
=Python=, commenter votre travail et rÃ©pondre aux diffÃ©rents petits exercices en
utilisant des blocs =Markdown=. 

_Note importante :_ 

Prenez le temps de bien prÃ©senter et rÃ©diger vos /notebooks/. Vous devez considÃ©rer un
/notebook/ comme un rapport technique susceptible d'Ãªtre communiquÃ© en entreprise afin de
contribuer Ã  des prises de dÃ©cision.  

* Les types usuels

Un type correspond Ã  la faÃ§on dont =Python= reprÃ©sente certaines catÃ©gories de donnÃ©es
homogÃ¨nes. Dans ce TD, nous Ã©tudierons certains types largement utilisÃ©s en =Python=. 

Il existe de nombreux types prÃ©dÃ©finis en =Python= tels que :
- les nombres entiers comme 11 ;
- les nombres rÃ©els comme 21.213 ;
- les chaÃ®nes de caractÃ¨res comme "Bonjour".

Les nombres entiers, les nombres rÃ©els et les chaÃ®nes de caractÃ¨res sont associÃ©s Ã  un type de
donnÃ©es =Python= particulier. Le Tableau ci-dessous illustre la notion de type avec
quelques exemples. La premiÃ¨re colonne indique l'expression et la seconde colonne indique le type de
donnÃ©e correspondant.

#+ATTR_LATEX: :environment tabular :align ll
#+ATTR_LATEX: :center t
#+ATTR_LATEX: :font \normalsize
#+ATTR_LATEX: :booktabs t
| Expression | Type =Python= |
|------------+---------------|
|         11 | =int=         |
|     21.213 | =float=       |
|  "Bonjour" | =str=         |

Pour connaÃ®tre le type d'une expression, il faut utiliser la fonction =type= comme suit :
#+attr_latex: :options bgcolor=almostwhite, frame=lines
#+BEGIN_SRC ipython :tangle td2.py :session :results raw drawer code :exports code
type(11)
#+END_SRC
#+attr_latex: :options bgcolor=almostwhite, frame=lines 
#+BEGIN_SRC ipython :tangle td2.py :session :results raw drawer code :exports code
type(21.213)
#+END_SRC
#+attr_latex: :options bgcolor=almostwhite, frame=lines
#+BEGIN_SRC ipython :tangle td2.py :session :results raw drawer code :exports code
type("Bonjour")
#+END_SRC

_Remarques :_
- Le type =str= correspond aux chaÃ®nes de caractÃ¨res que l'on dÃ©finit en =Python= entre guillemets
  ou entre apostrophes, e.g. ="abc", 'abc', "01 - Introduction au typage"=.  
- Les nombres entiers peuvent Ãªtre nÃ©gatifs ou positifs, e.g. =-1015, -5, 0, 1, 37=
- Les flottants sont des nombres rÃ©els, e.g. =-5.0, 13.4586, -1.87e-11=. Ils incluent donc les entiers et les nombres 
  entre les entiers. 

Il est possible de changer le type d'une expression en =Python=, c'est ce qu'on appelle le
/typecasting/. Vous pouvez par exemple convertir un =int= en =float= en utilisant la fonction
=float= :
#+attr_latex: :options bgcolor=almostwhite, frame=lines
#+BEGIN_SRC ipython :tangle td2.py :session :results raw drawer code :exports code
float(2)
#+END_SRC
Le rÃ©sultat ne change pas vraiment mais notez que =Python= affiche =2.0= au lieu de =2= indiquant
que la conversion a bien eu lieu.

Il n'est pas toujours possible de changer le type d'une expression. Par exemple, essayez de transformer une
chaÃ®ne de caractÃ¨res en =float= :
#+attr_latex: :options bgcolor=almostwhite, frame=lines
#+BEGIN_SRC ipython :exports code :eval no
float("Ãa va faire mal")
#+END_SRC
En revanche si la chaÃ®ne reprÃ©sente un nombre flottant, la conversion fonctionne ! Par exemple :
#+attr_latex: :options bgcolor=almostwhite, frame=lines
#+BEGIN_SRC ipython :tangle td2.py :session :results raw drawer code :exports code
float("3.14")
#+END_SRC

Par ailleurs, certaines conversions sont possibles mais entraÃ®nent des changements ou perte
d'information qu'il convient de bien maÃ®triser. La fonction =int= permet par exemple de transformer des nombres en entier. Pour
illustrer le comportement de cette fonction, essayez de convertir les nombres flottants suivants :
#+attr_latex: :options bgcolor=almostwhite, frame=lines
#+BEGIN_SRC ipython :tangle td2.py :session :results raw drawer code :exports code
int(2.7)
#+END_SRC
#+attr_latex: :options bgcolor=almostwhite, frame=lines
#+BEGIN_SRC ipython :tangle td2.py :session :results raw drawer code :exports code
int(-2.7)
#+END_SRC
#+attr_latex: :options bgcolor=almostwhite, frame=lines
#+BEGIN_SRC ipython :tangle td2.py :session :results raw drawer code :exports code
int(-1.2)
#+END_SRC
La fonction =int= revient dans ce cas Ã  calculer la partie entiÃ¨re d'un nombre.

La fonction =str= permet de convertir une expression en chaÃ®ne de caractÃ¨res. Cette fonction peut
Ãªtre appliquÃ©e sur toutes les expressions =Python=. Autrement dit, =Python= peut tout convertir en
chaÃ®ne de caractÃ¨res. Exemples :
#+attr_latex: :options bgcolor=almostwhite, frame=lines
#+BEGIN_SRC ipython :tangle td2.py :session :results raw drawer code :exports code
str(63)
#+END_SRC
#+attr_latex: :options bgcolor=almostwhite, frame=lines
#+BEGIN_SRC ipython :tangle td2.py :session :results raw drawer code :exports code
str(-78.1)
#+END_SRC
#+attr_latex: :options bgcolor=almostwhite, frame=lines
#+BEGIN_SRC ipython :tangle td2.py :session :results raw drawer code :exports code
str(1.43e-12)
#+END_SRC
#+attr_latex: :options bgcolor=almostwhite, frame=lines
#+BEGIN_SRC ipython :tangle td2.py :session :results raw drawer code :exports code
str("Bonjour")
#+END_SRC
#+attr_latex: :options bgcolor=almostwhite, frame=lines
#+BEGIN_SRC ipython :tangle td2.py :session :results raw drawer code :exports code
str(type("Bonjour"))
#+END_SRC


Le type boolÃ©en est un autre type important en =Python=. Un boolÃ©en peut prendre deux valeurs. La
premiÃ¨re valeur est =True= (vrai) avec un =T= majuscule et la seconde est =False= avec une =F=
majuscule. En utilisant la fonction =type= sur une valeur boolÃ©enne, nous obtenons le type =bool= :
#+attr_latex: :options bgcolor=almostwhite, frame=lines
#+BEGIN_SRC ipython :tangle td2.py :session :results raw drawer code :exports code
type(True)
#+END_SRC
#+attr_latex: :options bgcolor=almostwhite, frame=lines
#+BEGIN_SRC ipython :tangle td2.py :session :results raw drawer code :exports code
type(False)
#+END_SRC

Il est possible de convertir un boolÃ©en en entier et vice-versa. ExpÃ©rimentez vous mÃªme ces
conversions pour en dÃ©duire la rÃ¨gle sous-jacente :
#+attr_latex: :options bgcolor=almostwhite, frame=lines
#+BEGIN_SRC ipython :tangle td2.py :session :results raw drawer code :exports code
int(False)
#+END_SRC
#+attr_latex: :options bgcolor=almostwhite, frame=lines
#+BEGIN_SRC ipython :tangle td2.py :session :results raw drawer code :exports code
int(True)
#+END_SRC
#+attr_latex: :options bgcolor=almostwhite, frame=lines
#+BEGIN_SRC ipython :tangle td2.py :session :results raw drawer code :exports code
bool(0)
#+END_SRC
#+attr_latex: :options bgcolor=almostwhite, frame=lines
#+BEGIN_SRC ipython :tangle td2.py :session :results raw drawer code :exports code
bool(1)
#+END_SRC
#+attr_latex: :options bgcolor=almostwhite, frame=lines
#+BEGIN_SRC ipython :tangle td2.py :session :results raw drawer code :exports code
bool(0.5)
#+END_SRC
#+attr_latex: :options bgcolor=almostwhite, frame=lines
#+BEGIN_SRC ipython :tangle td2.py :session :results raw drawer code :exports code
bool(-10)
#+END_SRC

* OpÃ©rations mathÃ©matiques

L'interprÃ©teur =Python= est capable de rÃ©aliser toutes les opÃ©rations arithmÃ©tiques usuelles. Le
Tableau suivant prÃ©sente la syntaxe pour rÃ©aliser ces opÃ©rations.

#+ATTR_LATEX: :environment tabular :align llll
#+ATTR_LATEX: :center t
#+ATTR_LATEX: :font \normalsize
#+ATTR_LATEX: :booktabs t
| OpÃ©ration                       | OpÃ©rateur | Exemple   | RÃ©sultat |
|---------------------------------+-----------+-----------+----------|
| addition                        | =+=       | =4 + 7.1= | =11.1=   |
| soustraction                    | =-=       | =10 - 23= | =-13=    |
| multiplication                  | =*=       | =3.0 * 2= | =6.0=    |
| division rÃ©elle                 | =/=       | =5 / 2=   | =2.5=    |
| division euclidienne (quotient) | =//=      | =5 // 2=  | =2=      |
| division euclidienne (reste)    | =%=       | =5 % 2=   | =1=      |
| puissance                       | =**=      | =3**4=    | =81=     |

=Python= suit les conventions mathÃ©matiques standards suivante pour Ã©valuer les expressions
mathÃ©matiques :
- Les opÃ©rations entre parenthÃ¨ses sont effectuÃ©es en premier en dÃ©butant par le niveau de
  parenthÃ¨ses le plus imbriquÃ© et en remontant itÃ©rativement vers le moins imbriquÃ©.
- Ã un niveau donnÃ©, les multiplications et les divisions sont calculÃ©es en premier suivies des
  additions et soustractions.
- Deux opÃ©rations successives ayant la mÃªme prioritÃ© sont rÃ©alisÃ©es de gauche Ã  droite.

Dans l'exemple suivant :
#+attr_latex: :options bgcolor=almostwhite, frame=lines
#+BEGIN_SRC ipython :tangle td2.py :session :results raw drawer code :exports code
(3 + 4*2)*(10/(3*5-5))
#+END_SRC

L'interprÃ©teur =Python= procÃ¨de dans cet ordre :
1. =(3*5 - 5) = (15 - 5) = 10= ;
2. =(3 + 4*2) = (3 + 8) = 11= ;
3. =(10/10) = 1.0= ;
4. =11/1.0 = 11.0=.

* Les variables

Comme dans la plupart des langages de programmation, les variables servent simplement Ã  stocker des
valeurs pour en faciliter la rÃ©utilisation.

Prenons l'exemple suivant :  
#+attr_latex: :options bgcolor=almostwhite, frame=lines
#+BEGIN_SRC ipython :tangle td2.py :session :results raw drawer code :exports code
ma_variable = 1
#+END_SRC
Nous attribuons ici la valeur de 1 Ã  la variable =ma_variable= en utilisant l'opÃ©rateur
d'affectation, c'est-Ã -dire le signe Ã©gal. Nous pouvons ensuite utiliser la valeur ailleurs dans le
code en tapant le nom exact de la variable :
#+attr_latex: :options bgcolor=almostwhite, frame=lines
#+BEGIN_SRC ipython :tangle td2.py :session :results raw drawer code :exports code
ma_variable - 10
#+END_SRC

Nous pouvons bien sÃ»r stocker le rÃ©sultat d'expressions plus complexes faisant Ã©ventuellement
intervenir d'autres variables. Par exemple : 
#+attr_latex: :options bgcolor=almostwhite, frame=lines
#+BEGIN_SRC ipython :tangle td2.py :session :results raw drawer code :exports code
seconde_variable = 2*ma_variable/3 + ma_variable
print(seconde_variable)
#+END_SRC
Notez au passage l'utilisation de la fonction =print= permettant d'afficher le contenu d'une
variable. 

Il est souvent trÃ¨s utile de mettre Ã  jour la valeur d'une variable en utilisant sa valeur
courante :
#+attr_latex: :options bgcolor=almostwhite, frame=lines
#+BEGIN_SRC ipython :tangle td2.py :session :results raw drawer code :exports code
seconde_variable = seconde_variable + 1
print(seconde_variable)
#+END_SRC
N'hÃ©sitez pas Ã  utiliser rÃ©guliÃ¨rement la fonction =type= sur vos variables afin de bien comprendre
la nature des objets =Python= que vous manipulez.
#+attr_latex: :options bgcolor=almostwhite, frame=lines
#+BEGIN_SRC ipython :tangle td2.py :session :results raw drawer code :exports code
type(seconde_variable)
#+END_SRC

_Exercice :_

Supposons que nous disposons d'une variable dont la valeur est un nombre de secondes :
#+attr_latex: :options bgcolor=almostwhite, frame=lines
#+BEGIN_SRC ipython :tangle td2.py :session :results raw drawer code :exports code
nombre_secondes = 3569
#+END_SRC

Ãcrivez un petit code =Python= permettant de convertir ce nombre de secondes en heures, minutes et
secondes. Vous devez bien sÃ»r utiliser la variable =nombre_secondes= dans vos calculs.

Solution :
#+attr_latex: :options bgcolor=black, style=bw, frame=lines
#+BEGIN_SRC ipython :tangle td2.py :session :results raw drawer code :exports code
nombre_minutes = nombre_secondes // 60
nombre_secondes_restantes = nombre_secondes % 60
nombre_heures = nombre_minutes // 60
nombre_minutes_restantes = nombre_minutes % 60
print("nombre d'heures = " + str(nombre_heures))
print("nombre de minutes = " + str(nombre_minutes_restantes))
print("nombre de secondes = " + str(nombre_secondes_restantes))
#+END_SRC
 
_Remarques pour avoir du style :_
- Il est important de crÃ©er vos variables avec des noms ayant du sens. Il est largement prÃ©fÃ©rable
  de manipuler des variables ayant de longs noms explicites plutÃ´t que des variables ayant des noms
  courts mais obscurs. Autrement dit, ne pas hÃ©siter Ã  utiliser =nombre_heures= pour une variable
  contenant un nombre d'heures plutÃ´t que =nb_h= ou pire =h=.
- En =Python=, il est recommandÃ© d'Ã©crire les variables en minuscules en sÃ©pÃ©rant les mots par des
  /underscore/. 
 
* Manipulation des chaÃ®nes de caractÃ¨res
** DÃ©finition
Nous rappelons qu'en =Python=, une chaÃ®ne de caractÃ¨res (de type =str=) est dÃ©finie par une
expression contenue entre deux guillemets ou deux apostrophes, e.g. ="Kawhi Leonard"= ou ='Kawhi
Leonard'=. 

Une chaÃ®ne de caractÃ¨res peut contenir tous types de caractÃ¨res (lettres, espaces, chiffres,
 caractÃ¨res spÃ©ciaux), e.g. ="Kawhi Leonard, NÂ°2 @ LA-C !"=. Il est mÃªme possible de dÃ©finir une
 chaÃ®ne vide par =""=.

La fonction =len= permet de calculer la longueur d'une chaÃ®ne de caractÃ¨re. 
#+attr_latex: :options bgcolor=almostwhite, frame=lines
#+BEGIN_SRC ipython :tangle td2.py :session :results raw drawer code :exports code
len("")
#+END_SRC
#+attr_latex: :options bgcolor=almostwhite, frame=lines
#+BEGIN_SRC ipython :tangle td2.py :session :results raw drawer code :exports code
len("Bonjour")
#+END_SRC
#+attr_latex: :options bgcolor=almostwhite, frame=lines
#+BEGIN_SRC ipython :tangle td2.py :session :results raw drawer code :exports code
joueur_basket = "Kawhi Leonard, NÂ°2 @ LA-C !"
len(joueur_basket)
#+END_SRC


** Indexation basique
En =Python= (et comme dans bien d'autres langages de programmation), une chaÃ®ne de caractÃ¨res est
une suite (ou sÃ©quence) ordonnÃ©e de caractÃ¨res indexÃ©e par des nombres entiers. Autrement dit,
chaque caractÃ¨re d'une chaÃ®ne est accessible par son index. La correspondance caractÃ¨re/index pour
la chaÃ®ne ="Kawhi Leonard, NÂ°2"= est prÃ©sentÃ©e dans le tableau suivant :
#+ATTR_LATEX: :environment tabular :align |l|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|
#+ATTR_LATEX: :center t
#+ATTR_LATEX: :font \normalsize
#+ATTR_LATEX: :booktabs t
| CaractÃ¨re | K | a | w | h | i |   | L | e | o | n |  a |  r |  d |  , |    |  N |  Â° |  2 |
|-----------+---+---+---+---+---+---+---+---+---+---+----+----+----+----+----+----+----+----|
| Index     | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 | 16 | 17 |

Pour accÃ©der Ã  un caractÃ¨re d'une chaÃ®ne par son index, il faut utiliser l'opÃ©rateur =[]= (crochets)
comme suit :
#+attr_latex: :options bgcolor=almostwhite, frame=lines
#+BEGIN_SRC ipython :tangle td2.py :session :results raw drawer code :exports code
joueur_basket = "Kawhi Leonard, NÂ°2"
print(joueur_basket[0])
print(joueur_basket[1])
print(joueur_basket[12])
print(joueur_basket[14])
print(joueur_basket[17])
#+END_SRC

_Remarque geek :_

=Python= fait partie de la grande famille des langages qui indexe les
listes/sÃ©quences Ã  partir de l'indice 0 comme le =C=, =C++=, =Java=. Par comparaison, le langage =R= indexe
les listes Ã  partir de l'indice 1.

_Notes :_ 

Une chaÃ®ne de caractÃ¨res est un objet invariable (en =Python=, on parle d'objet /immuable/). Cela
signifie qu'il est impossible de modifier un caractÃ¨re d'une chaÃ®ne Ã  partir de son
index. L'opÃ©ration =joueur_basket[1] = "A"= n'est pas autorisÃ©e et renvoie une erreur.  

En outre, =Python= offre la possibilitÃ© d'utiliser une indexation nÃ©gative afin
d'accÃ©der aux Ã©lÃ©ments d'une chaÃ®ne de caractÃ¨res par la fin. Le tableau suivant reprend l'exemple
de la chaÃ®ne prÃ©cÃ©dent en y ajoutant l'indexation nÃ©gative :
#+ATTR_LATEX: :environment tabular 
#+ATTR_LATEX: :align |l|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|
#+ATTR_LATEX: :center t
#+ATTR_LATEX: :font \footnotesize
#+ATTR_LATEX: :booktabs t
| CaractÃ¨re     |   K |   a |   w |   h |   i |     |   L |   e |   o |  n |  a |  r |  d |  , |    |  N |  Â° |  2 |
|---------------+-----+-----+-----+-----+-----+-----+-----+-----+-----+----+----+----+----+----+----+----+----+----|
| Index         |   0 |   1 |   2 |   3 |   4 |   5 |   6 |   7 |   8 |  9 | 10 | 11 | 12 | 13 | 14 | 15 | 16 | 17 |
|---------------+-----+-----+-----+-----+-----+-----+-----+-----+-----+----+----+----+----+----+----+----+----+----|
| Index nÃ©gatif | -18 | -17 | -16 | -15 | -14 | -13 | -12 | -11 | -10 | -9 | -8 | -7 | -6 | -5 | -4 | -3 | -2 | -1 |

_Exercice :_

Afficher les caractÃ¨res de l'exemple prÃ©cÃ©dent en utilisant l'indexation nÃ©gative.

Solution :
#+attr_latex: :options bgcolor=black, style=bw, frame=lines
#+BEGIN_SRC ipython :tangle td2.py :session :results raw drawer code :exports code
joueur_basket = "Kawhi Leonard, NÂ°2"
print(joueur_basket[-18])
print(joueur_basket[-17])
print(joueur_basket[-6])
print(joueur_basket[-4])
print(joueur_basket[-1])
#+END_SRC

** Indexation avancÃ©e

=Python= offre la possibilitÃ© d'accÃ©der rapidement Ã  des morceaux (ou sous-chaÃ®nes) d'une chaÃ®ne de
caractÃ¨res grÃ¢ce aux fonctionnalitÃ©s de /slicing/. Les opÃ©rations de /slicing/ font intervenir
l'opÃ©rateur =:= afin de dÃ©finir la plage d'Ã©lÃ©ments auxquels nous souhaitons accÃ©der. Par exemple,
pour accÃ©der Ã  la sous-chaÃ®ne ="Kawhi"=, il faut Ã©crire :
#+attr_latex: :options bgcolor=almostwhite, frame=lines
#+BEGIN_SRC ipython :tangle td2.py :session :results raw drawer code :exports code
joueur_basket = "Kawhi Leonard, NÂ°2"
prenom = joueur_basket[0:5]
print(prenom)
#+END_SRC
L'opÃ©ration de /slicing/ =0:5= signifie "rÃ©cupÃ©rer les caractÃ¨res de l'indice 0 Ã  l'indice 5 non inclus",
autrement dit, "rÃ©cupÃ©rer les caractÃ¨res des indices 0, 1, 2, 3, 4".

Il est Ã©galement possible de rÃ©aliser des opÃ©rations de /slicing/ en indiquant le "pas" de parcours
de la chaÃ®ne. Par exemple, pour accÃ©der Ã  un caractÃ¨re sur trois en dÃ©marrant du ="w"= et en allant
jusqu'Ã  la virgule, il faut Ã©crire :
#+attr_latex: :options bgcolor=almostwhite, frame=lines
#+BEGIN_SRC ipython :tangle td2.py :session :results raw drawer code :exports code
joueur_basket = "Kawhi Leonard, NÂ°2"
un_sur_trois = joueur_basket[2:15:3]
print(un_sur_trois)
#+END_SRC
L'opÃ©ration de /slicing/ =2:15:3= se lit "rÃ©cupÃ©rer les caractÃ¨res de l'indice 2 Ã  l'indice 15 non
inclus avec un pas de 3, autrement dit, rÃ©cupÃ©rer les caractÃ¨res des indices 2, 5, 8, 11 et 14.

_Exercices :_
En utilisant la chaÃ®ne ="Kawhi Leonard, NÂ°2"=, utiliser une opÃ©ration de /slicing/ pour rÃ©cupÃ©rer :
1. la chaÃ®ne ="Leonard"= ;
2. la chaÃ®ne ="Load Â°"=.

Solution :
#+attr_latex: :options bgcolor=black, style=bw, frame=lines
#+BEGIN_SRC ipython :tangle td2.py :session :results raw drawer code :exports code
print(joueur_basket[6:13])
print(joueur_basket[6:-1:2])
#+END_SRC

** OpÃ©rations sur les chaÃ®nes

Pour concatÃ©ner deux chaÃ®nes de caractÃ¨res, il faut utiliser l'opÃ©rateur =+= de la faÃ§on suivante :
#+attr_latex: :options bgcolor=almostwhite, frame=lines
#+BEGIN_SRC ipython :tangle td2.py :session :results raw drawer code :exports code
joueur_basket = "Kawhi Leonard, NÂ°2"
verite_absolue = joueur_basket + " est le meilleur"
print(verite_absolue)
#+END_SRC

Il est Ã©galement possible de rÃ©pliquer une chaÃ®ne de caractÃ¨res avec l'opÃ©rateur =*=. Par exemple :
#+attr_latex: :options bgcolor=almostwhite, frame=lines
#+BEGIN_SRC ipython :tangle td2.py :session :results raw drawer code :exports code
3*"Kawhi ! "
#+END_SRC

** Les sÃ©quences d'Ã©chappement 

Les sÃ©quences d'Ã©chappement dÃ©signent des sÃ©quences de caractÃ¨res particuliÃ¨res qui sont
interprÃ©tÃ©es par les fonctions d'affichage (e.g. =print=) pour formater la chaÃ®ne d'une certaine
maniÃ¨re.  

La sÃ©quence ="\n"= sert Ã  insÃ©rer un saut de ligne.
#+attr_latex: :options bgcolor=almostwhite, frame=lines
#+BEGIN_SRC ipython :tangle td2.py :session :results raw drawer code :exports code
chaine = "Encore une tempÃªte en\nBretagne..."
print(chaine)
#+END_SRC

La sÃ©quence ="\t"= sert Ã  insÃ©rer une tabulation.
#+attr_latex: :options bgcolor=almostwhite, frame=lines
#+BEGIN_SRC ipython :tangle td2.py :session :results raw drawer code :exports code
chaine = "Encore une tempÃªte en\tBretagne..."
print(chaine)
#+END_SRC

La sÃ©quence ="\r"= sert Ã  insÃ©rer un retour en dÃ©but de ligne.
#+attr_latex: :options bgcolor=almostwhite, frame=lines
#+BEGIN_SRC ipython :tangle td2.py :session :results raw drawer code :exports code
chaine = "Encore une tempÃªte en\rBretagne..."
print(chaine)
#+END_SRC

_Remarque :_ 

Si vous souhaitez utiliser le caractÃ¨re ="\"= dans une chaÃ®ne de caractÃ¨res sans pour
autant que ce dernier ne soit interprÃ©tÃ© dans une sÃ©quence d'Ã©chappement, il suffit de doubler le
caractÃ¨re ="\"=. Par exemple :
#+attr_latex: :options bgcolor=almostwhite, frame=lines
#+BEGIN_SRC ipython :tangle td2.py :session :results raw drawer code :exports code
chaine = "Encore une tempÃªte en\\nBretagne..."
print(chaine)
#+END_SRC

** MÃ©thodes de chaÃ®nes de caractÃ¨res

En =Python=, il existe deux faÃ§ons de rÃ©aliser des traitements sur un Ã©lÃ©ment :
1. Avec une fonction, e.g. =len=, =type=, =int=, =print=, etc. Dans ce cas, on passe l'Ã©lÃ©ment en
   argument de la fonction entre parenthÃ¨ses et on rÃ©cupÃ¨re le rÃ©sultat, e.g. =len("abc")= retourne
   la valeur 3.
2. Avec une mÃ©thode disponible pour le type de l'Ã©lÃ©ment manipulÃ©. Les mÃ©thodes s'utilisent avec la
   syntaxe suivante =<nom de l'Ã©lÃ©ment>.<nom de la mÃ©thode>(arguments de la mÃ©thode)=.

Le type "chaÃ®ne de caractÃ¨res" (i.e. type =str=) possÃ¨de de nombreuses mÃ©thodes permettant de
manipuler et transformer les chaÃ®nes de caractÃ¨res. Les paragraphes suivants en abordent quelques-unes.

La mÃ©thode =upper= permet de transformer une chaÃ®ne en majuscules :
#+attr_latex: :options bgcolor=almostwhite, frame=lines
#+BEGIN_SRC ipython :tangle td2.py :session :results raw drawer code :exports code
mon_texte = "Encore une tempÃªte en Bretagne..."
mon_texte.upper()
#+END_SRC
Quelques remarques :
1. La mÃ©thode =upper= n'a pas besoin d'argument, d'oÃ¹ les parenthÃ¨ses vides.  
2. La mÃ©thode =upper= renvoie une nouvelle chaÃ®ne de caractÃ¨res. Le contenu de la variable
   =mon_texte= n'est pas modifiÃ©.
3. Ãcrire directement ="Encore une tempÃªte en Bretagne...".upper()=
   amÃ¨ne au mÃªme rÃ©sultat.

La mÃ©thode =lower= transforme une chaÃ®ne en minuscules.

La mÃ©thode =replace= permet de remplacer une partie d'une chaÃ®ne par une autre :
#+attr_latex: :options bgcolor=almostwhite, frame=lines
#+BEGIN_SRC ipython :tangle td2.py :session :results raw drawer code :exports code
mon_texte = "Encore une tempÃªte en Bretagne..."
nouveau_texte = mon_texte.replace("une tempÃªte", "du beau temps")
print(nouveau_texte)
#+END_SRC
Ã noter que la mÃ©thode =replace= ne modifie pas la chaÃ®ne sur laquelle la mÃ©thode est appliquÃ©e mais
renvoie une nouvelle chaÃ®ne modifiÃ©e.

La mÃ©thode =find= permet de rechercher si une chaÃ®ne est contenue dans la chaÃ®ne sur laquelle la
mÃ©thode est appliquÃ©e :
#+attr_latex: :options bgcolor=almostwhite, frame=lines
#+BEGIN_SRC ipython :tangle td2.py :session :results raw drawer code :exports code
mon_texte = "Encore une tempÃªte en Bretagne..."
indice = mon_texte.find("temp")
#+END_SRC
#+attr_latex: :options bgcolor=almostwhite, frame=lines
#+BEGIN_SRC ipython :tangle td2.py :session :results raw drawer code :exports code
mon_texte = "Encore une tempÃªte en Bretagne..."
indice = mon_texte.find("Normandie")
#+END_SRC
La mÃ©thode =find= renvoie l'indice du premier caractÃ¨re de la chaÃ®ne recherchÃ© si cette derniÃ¨re est
prÃ©sente et la valeur =-1= si la chaÃ®ne recherchÃ©e n'est pas trouvÃ©e.

** Le formatage des chaÃ®nes de caractÃ¨res
# cf http://pascal.ortiz.free.fr/contents/python/chaines_formatees/les_f_chaines__la_methode_format.html

*** Notion de chaÃ®ne formatÃ©e

Le formatage de chaÃ®nes est une possibilitÃ© offerte par de nombreux langages de programmation pour
mettre en forme une chaÃ®ne de caractÃ¨res Ã  partir dâun modÃ¨le prÃ©dÃ©fini. 

Supposons que l'on souhaite gÃ©nÃ©rer automatiquement des phrases ayant la structure suivante :
#+attr_latex: :options bgcolor=almostwhite, frame=lines
#+BEGIN_SRC ipython :tangle td2.py :session :results raw drawer code :exports code
"Son nom est NoÃ© et il a 8 ans."
"Son nom est Balam et il a 38 ans."
"Son nom est Jean et il a 82 ans."
#+END_SRC
Dâune phrase Ã  lâautre, seuls le nom et le nombre reprÃ©sentant lâÃ¢ge changent. Les chaÃ®nes ci-dessus
sont dites "formatÃ©es", c'est Ã  dire qu'elles possÃ¨dent toutes la mÃªme structure de la forme : 

=Son nom est XXX et il a YYY ans=. 

Seuls varient le nom =XXX= et lâÃ¢ge =YYY=. La chaÃ®ne =Son nom est XXX
et il a YYY ans.= est qualifiÃ©e de chaÃ®ne-modÃ¨le ou plus souvent /template/ en anglais. Les parties
Ã  remplacer sont appelÃ©es champs de remplacement ou /replacement field/ en anglais. Un /template/
est donc un modÃ¨le Ã  partir duquel dâautres chaÃ®nes vont Ãªtre produites par substitution. 

=Python 3= dispose de trois syntaxes pour construire des chaÃ®nes formatÃ©es :
- les f-chaÃ®nes, /f-string/ en anglais ;
- les chaÃ®nes formatÃ©es avec la mÃ©thode =format= ;
- les chaÃ®nes formatÃ©es avec l'opÃ©rateur =%= que nous n'Ã©tudierons car de moins en moins utilisÃ©es aujourd'hui.

*** f-chaÃ®nes

Pour des situations simples et dans de nombreuses situations courantes, les f-chaÃ®nes fournissent la
mÃ©thode la plus souple et la plus lisible. Elles nâexistent que depuis la version =3.6= de
=Python=. Voici un exemple d'utilisation d'une f-chaÃ®ne :
#+attr_latex: :options bgcolor=almostwhite, frame=lines
#+BEGIN_SRC ipython :tangle td2.py :session :results raw drawer code :exports code
nom = "NoÃ©"
age = 8
print(f"Son nom est {nom} et il a {age} ans.")
#+END_SRC
Il sâagit donc de chaÃ®nes de caractÃ¨res usuelles mais prÃ©cÃ©dÃ©es dâune lettre =f= (pour
"formatÃ©"). Il est alors possible de placer des expressions (et pas  
seulement des variables) entre accolades dans la chaÃ®ne et le remplacement se fait aprÃ¨s Ã©valuation
de lâexpression. L'exemple suivant montre qu'il est possible d'utiliser toute expression =Python=
entre les accolades de remplacement :
#+attr_latex: :options bgcolor=almostwhite, frame=lines
#+BEGIN_SRC ipython :tangle td2.py :session :results raw drawer code :exports code
nom = "NoÃ©"
age = 8
chaine = f"Son nom est {nom} et il n'a pas {age + 10} ans."
print(chaine)
#+END_SRC

*** La mÃ©thode =format=

La mÃ©thode =format= est plus gÃ©nÃ©rale que les f-chaÃ®nes et plus adaptÃ©e dans certaines
situations. Mais une large partie de sa syntaxe est commune avec les f-chaÃ®nes. 

La mÃ©thode =format= repose sur le mÃªme principe de substitution d'expression =Python= dans une
chaÃ®ne de caractÃ¨re, exceptÃ© que les expressions sont renseignÃ©es dans les arguments de la mÃ©thode
=format= et non plus dans la chaÃ®ne directement. La premiÃ¨re Ã©tape consiste Ã  dÃ©finir un /template/
(chaÃ®ne modÃ¨le) comme suit :  
#+attr_latex: :options bgcolor=almostwhite, frame=lines
#+BEGIN_SRC ipython :tangle td2.py :session :results raw drawer code :exports code
modele = "Son nom est {} et il a {} ans."

Noe = modele.format("NoÃ©", 8)
print(Noe)

Balam = modele.format("Balam", 38)
print(Balam)

print(modele.format("Jean", 82))
#+END_SRC
_Remarques :_
- La variable =modele= contient la chaÃ®ne-modÃ¨le. Câest une chaÃ®ne de caractÃ¨res classique qui
  contient des champs de remplacement reprÃ©sentÃ©s par des paires dâaccolades ={}=.
- La variable =Noe= contient la chaÃ®ne formatÃ©e construite Ã  lâaide de la mÃ©thode =format=. La
  premiÃ¨re paire dâaccolades est remplacÃ©e dans la chaÃ®ne-modÃ¨le par le premier argument de la
  mÃ©thode =format=, et la deuxiÃ¨me paire d'accolades par le deuxiÃ¨me argument de la mÃ©thode
  =format=.
- Les variables =Balam= et l'expression dans le dernier =print= suivent le mÃªme principe.

En rÃ©sumÃ©, les deux Ã©tapes de crÃ©ation dâune chaÃ®ne formatÃ©e sont :
1. Construction de la chaÃ®ne-modÃ¨le. Les parties Ã  remplacer sont placÃ©es entre des paires
   dâaccolades dans le modÃ¨le. 
2. GÃ©nÃ©ration de la chaÃ®ne formatÃ©e par appel de la mÃ©thode =format= sur la chaÃ®ne-modÃ¨le. Le
   modÃ¨le est ainsi "rempli" par les arguments renseignÃ©s dans la mÃ©thode =format=. 

Le systÃ¨me de formatage des chaÃ®nes de caractÃ¨res proposÃ©es en =Python= est trÃ¨s riche. N'hÃ©sitez
pas Ã  parcourir les exemples de la [[https://docs.python.org/fr/3.5/library/string.html][documentation officielle]] pour en savoir plus.

_Exercices :_

Ãvaluer les commandes suivantes afin de dÃ©duire le comportement de la mÃ©thode =format= :
#+attr_latex: :options bgcolor=almostwhite, frame=lines
#+BEGIN_SRC ipython :tangle td2.py :session :results raw drawer code :exports code
modele = "une {1}, une {2} et une {0}"
print(modele.format("pomme", "poire", "prune"))
#+END_SRC
#+attr_latex: :options bgcolor=almostwhite, frame=lines
#+BEGIN_SRC ipython :tangle td2.py :session :results raw drawer code :exports code
modele = "une {1}, une {2} et une {1}"
print(modele.format("pomme", "poire", "prune"))
#+END_SRC
#+attr_latex: :options bgcolor=almostwhite, frame=lines
#+BEGIN_SRC ipython :tangle td2.py :session :results raw drawer code :exports code
modele = "Son nom est {prenom} et il a {age} ans."
chaine_formatee=modele.format(age=42, prenom= "Arthur")
print(chaine_formatee)
#+END_SRC


* Les commentaires

Les commentaires en =Python= commencent avec un caractÃ¨re diÃ¨se, =#=, et sâÃ©tendent jusquâÃ  la fin de la
ligne. Un commentaire peut apparaÃ®tre au dÃ©but dâune ligne ou Ã  la suite dâune ligne de code,
mais pas Ã  lâintÃ©rieur dâune chaÃ®ne de caractÃ¨res. Un caractÃ¨re diÃ¨se Ã  lâintÃ©rieur dâune
chaÃ®ne de caractÃ¨res est juste un caractÃ¨re diÃ¨se. Comme les commentaires ne servent quâÃ  expliquer
le code et ne sont pas interprÃ©tÃ©s par Python, ils peuvent Ãªtre ignorÃ©s lorsque vous tapez les
exemples. 

#+attr_latex: :options bgcolor=almostwhite, frame=lines
#+BEGIN_SRC ipython :tangle td2.py :session :results raw drawer code :exports code
# Ceci est un commentaire
spam = 1  # Voici un autre commentaire
          # ... et un encore un autre
text = "# Ce n'est pas un commentaire car le texte est entre guillemets"
#+END_SRC
