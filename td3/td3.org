# -*- coding: utf-8 -*-

#+TITLE: Les structures de données =Python=
#+AUTHOR: Roland Donat
#+EMAIL: roland.donat@univ-ubs.fr
# #+DATE: 

# ==============================================
# Document Configuration
# ======================
# Orgmode
:CONFIG:
#+LANGUAGE: fr
#+OPTIONS: H:3 num:t toc:nil \n:nil @:t ::t |:t ^:{} f:t TeX:t author:t d:nil timestamp:nil
#+OPTIONS: html-postamble:nil
#+STARTUP: content 
#+STARTUP: hidestars
#+DRAWERS: CONFIG OPTIONS CACHE MACROS
#+TODO: TODO(t) INPROGRESS(p) | DONE(d)
#+BIND: org-latex-table-scientific-notation "{%s}E{%s}"
:END:

# LaTeX
# -----
# Class parameters
:CONFIG:
#+LaTeX_CLASS: ubs-note
#+LaTeX_CLASS_OPTIONS: [a4paper,twoside,11pt]
#+LATEX_HEADER: \thelang{FR}
#+LATEX_HEADER: \thesubtitle{}
#+LATEX_HEADER: \institution{IUT Vannes}
#+LATEX_HEADER: \course{Intoduction à \texttt{Python}}
#+LATEX_HEADER: \cursus{Licences professionnelles SDM/SIS}
#+LATEX_HEADER: \version{1.0}
:END:
# Packages
:CONFIG:
#+LATEX_HEADER: \usepackage[french]{babel}
#+LATEX_HEADER: \usepackage{graphicx}
#+LATEX_HEADER: \usepackage{amssymb}
#+LATEX_HEADER: \usepackage{amsmath}
#+LATEX_HEADER: \usepackage{amsfonts}
#+LATEX_HEADER: \usepackage{xcolor}
#+LATEX_HEADER: \usepackage{verbatim}
#+LATEX_HEADER: \usepackage{tabularx}
#+LATEX_HEADER: \usepackage{float}
#+LATEX_HEADER: \usepackage{lmodern}
#+LATEX_HEADER: \usepackage{natbib}
#+LATEX_HEADER: \usepackage{subfig}
#+LATEX_HEADER: \usepackage{booktabs}
#+LATEX_HEADER: \usepackage{minted}
:END:
# Layout
:CONFIG:
# Figures path
#+LATEX_HEADER: % Graphics path
#+LATEX_HEADER: \graphicspath{ 
#+LATEX_HEADER:   {./fig/}
#+LATEX_HEADER: }

# Colors
#+LATEX_HEADER: \definecolor{almostwhite}        {rgb}{0.85,0.85,0.85}

# Minted
# To control spaces between minted block
#+LATEX_HEADER: \AtBeginEnvironment{snugshade*}{\vspace{-1.25\FrameSep}}
#+LATEX_HEADER: \AfterEndEnvironment{snugshade*}{\vspace{-2\FrameSep}}
# #+LATEX_HEADER: \usemintedstyle{monokai}
# #+LATEX_HEADER: \renewcommand{\theFancyVerbLine}{\sffamily \footnotesize {\color{EMLogoBlue}\oldstylenums{\arabic{FancyVerbLine}}}}

# Captions
#+LATEX_HEADER: \captionsetup[table]{position=bottom,margin=90pt,font=small,labelfont=bf,labelsep=endash,format=plain}
#+LATEX_HEADER: \captionsetup[figure]{position=bottom,margin=90pt,font=small,labelfont=bf,labelsep=endash,format=plain}
#+LATEX_HEADER: \captionsetup[subfloat]{margin=0pt,font=footnotesize}

# Geometry
#+LATEX_HEADER: \usepackage{geometry}
#+LATEX_HEADER: \geometry{
#+LATEX_HEADER: %  nohead,
#+LATEX_HEADER:   top=2.25cm, 
#+LATEX_HEADER:   bottom=2.25cm, 
#+LATEX_HEADER:  left=2.5cm, 
#+LATEX_HEADER:  right=2.5cm}

#+LATEX_HEADER: \usepackage{setspace}
#+LATEX_HEADER: \onehalfspacing
#+LATEX_HEADER: % Supprime l'indentation
#+LATEX_HEADER: \setlength{\parindent}{0pt}
#+LATEX_HEADER: % Espacement entre les paragraphes
#+LATEX_HEADER: \setlength{\parskip}{2ex}

# List layout
#+LATEX_HEADER: \frenchbsetup{ListOldLayout=true} %FBReduceListSpacing=true,CompactItemize=false}

# References
#+LATEX: \renewcommand*{\refname}{}*
:END:
# LaTeX Compilator
:CONFIG:
#+BEGIN_SRC emacs-lisp :results silent :exports none
(setq org-latex-listings 'minted
      org-latex-minted-options nil ;; '(("frame" "lines")))
      org-latex-pdf-process
      '("xelatex -shell-escape -interaction nonstopmode -output-directory %o %f"
        "bibtex %b"
        "xelatex -shell-escape -interaction nonstopmode -output-directory %o %f"
        "xelatex -shell-escape -interaction nonstopmode -output-directory %o %f"))
#+END_SRC
:END:

# HTML
# ----
:CONFIG:
# Org HTML Macros
#+MACRO: NEWLINE @@latex:\\@@ @@html:<br>@@
#+MACRO: HTMLFONTSIZE @@html:<font size="$2">$1</font>@@
#+MACRO: SUBTITLE @@html:<div class="slidesubtitle">$1</div>@@

# HTML options
# ------------
# #+HTML_HEAD: <link rel="stylesheet" type="text/css" href="./css/edgemind.css" />
# #+HTML_HEAD: <link rel="stylesheet" type="text/css" href="./css/ensibs.css" />
# CSS to get the ReadTheDoc style
# #+HTML_HEAD: <link rel="stylesheet" type="text/css" href="https://www.pirilampo.org/styles/readtheorg/css/htmlize.css"/>
# #+HTML_HEAD: <link rel="stylesheet" type="text/css" href="https://www.pirilampo.org/styles/readtheorg/css/readtheorg.css"/>
# #+HTML_HEAD: <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
# #+HTML_HEAD: <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
# #+HTML_HEAD: <script type="text/javascript" src="https://www.pirilampo.org/styles/lib/js/jquery.stickytableheaders.js"></script>
# #+HTML_HEAD: <script type="text/javascript" src="https://www.pirilampo.org/styles/readtheorg/js/readtheorg.js"></script>
:END:

# Publishing
# ----------
:CONFIG:
#+BEGIN_SRC emacs-lisp :results silent :exports none
;; Define some export options here since in org-publish-project-alist some of them are not taken into account
;; e.g. with-toc nil
(defun my-html-export-options (plist backend)
  (cond 
    ((equal backend 'html)
     (plist-put plist :with-toc t)
     (plist-put plist :section-numbers nil)
     (plist-put plist :with-author t)
     (plist-put plist :with-email t)
     (plist-put plist :with-date t)
     ))
  plist)

(setq org-publish-project-alist
      '(
	
        ("main"
         :base-directory "./"
         :include ("rb_mod_stoch.org")
         :publishing-directory "./"
         :recursive nil
         :publishing-function org-html-publish-to-html
         :preparation-function (lambda () (setq org-export-filter-options-functions '(my-html-export-options)))
         :auto-preamble t
         :html-head  "<link rel='stylesheet' type='text/css' href='edgemind.css' />"
         :htmlized-source 
	 :section-numbers nil
         )
        ("td-html"
         :base-directory "./td/"
         :base-extension "org"
         :publishing-directory "./td"
         :recursive t
         :publishing-function org-html-publish-to-html
         :preparation-function (lambda () (setq org-export-filter-options-functions '(my-html-export-options)))
         :auto-preamble t
         :html-head  "<link rel='stylesheet' type='text/css' href='edgemind.css' />"
         :htmlized-source 
         )

	 ;; pdf
        ("td-pdf"
         :base-directory "./td/"
         :base-extension "org"
         :publishing-directory "./td"
         :recursive t
         :publishing-function org-latex-publish-to-pdf
         )

	 ("td-attach"
	 :base-directory "./td/"
	 :base-extension "xdsl\\|txt\\|csv\\|py\\|png"
         :publishing-directory "./td"
	 :recursive t
	 :publishing-function org-publish-attachment
	 )

	 ("cours-attach"
	 :base-directory "./cours/"
	 :base-extension "pdf\\|xdsl\\|txt\\|csv\\|py"
         :publishing-directory "./cours"
	 :recursive t
	 :publishing-function org-publish-attachment
	 )

        ("projet-html"
         :base-directory "./projet/"
         :base-extension "org"
         :publishing-directory "./projet"
         :recursive t
         :publishing-function org-html-publish-to-html
         :preparation-function (lambda () (setq org-export-filter-options-functions '(my-html-export-options)))
         :auto-preamble t
         :html-head  "<link rel='stylesheet' type='text/css' href='edgemind.css' />"
         :htmlized-source 
         )

	 ("projet-attach"
	 :base-directory "./projet/"
	 :base-extension "xdsl\\|txt\\|csv"
         :publishing-directory "./projet"
	 :recursive t
	 :publishing-function org-publish-attachment
	 )

	 ("css"
         :base-directory "./css/"
         :base-extension "css"
         :publishing-directory "./www/css"
         :publishing-function org-publish-attachment)
	 
	 ;("rb_mod_stoch" :components ("main" "td-pdf" "td-html" "td-attach" "cours-attach" "projet-html" "projet-attach" "css"))
	 ;("rb_mod_stoch" :components ("main" "td-pdf" "td-html" "projet-html"))
	 ("rb_mod_stoch" :components ("main"))

      ))
#+END_SRC
:END:

# ==============================================
# Document starts here
# ====================

# #+ATTR_LATEX: :width \textwidth
[[./fig/python_joke_index.jpg]]

#+LATEX: \clearpage

* Objectif

Ce TD aborde les principales structures de données disponibles en =Python=, à savoir :
- les tuples ;
- les listes ;
- les dictionnaires ;
- les ensembles.

Pour réaliser ce TD, créez un /notebook/ =Jupyter= dans le lequel vous allez exécuter votre code
=Python=, commenter votre travail et répondre aux différents petits exercices en
utilisant des blocs =Markdown=. 

_Note importante :_ 

Prenez le temps de bien présenter et rédiger vos /notebooks/. Vous devez considérer un
/notebook/ comme un rapport technique susceptible d'être communiqué en entreprise afin de
contribuer à des prises de décision.  

* Les tuples

Les tuples sont des séquences d'éléments ordonnées *non modifiables* (on parle d'objets immuables en
=Python=). Le rôle des
tuples est donc de stocker des éléments qui ne changeront pas au cours de l'exécution
d'un programme. Un tuple étant non modifiable, il ne sera pas possible d'ajouter ou supprimer des
éléments après sa création sans créer un nouveau tuple.

Pour créer un
tuple, il faut lister la suite de ses éléments en les séparant par des virgules à l'intérieur de
parenthèses. Voici par exemple, un tuple contenant 10 entiers représentant un score : 
#+attr_latex: :options bgcolor=almostwhite, frame=lines
#+BEGIN_SRC ipython :session :results raw drawer code :exports code
scores = (5, 5, 3, 4, 1, 4, 3, 4, 5, 2)
#+END_SRC

Les tuples peuvent contenir un mélange de différents types d'éléments :
#+attr_latex: :options bgcolor=almostwhite, frame=lines
#+BEGIN_SRC ipython :session :results raw drawer code :exports code
un_tuple_heterogene = ("chocolat", 2.0, ("un tuple dans un tuple", ),\
                       -1, False, (), 1e-3)
#+END_SRC
Quelques remarques :
- Le type des tuples est =tuple=.
- Un tuple peut contenir d'autres tuples. En fait, un tuple peut contenir n'importe quel objet
  =Python=.
- Un tuple a un élément s'écrit =(<unique_element>, )= et non simplement =(<unique_element>)= car
  =Python= pourrait confondre avec l'utilisation de parenthèses dans une formule mathématique.
- Le tuple vide s'écrit =()=.
- Pour éviter d'écrire une trop longue ligne de code nuisant à sa lisibilité, il est *fortement*
  recommandé de passer à la ligne en utilisant le caractère =\=.

Les tuples possèdent le même système d'indexation que les chaînes de caractères (cf. TD2), à savoir
une indexation par nombres entiers débutant à 0. Sur l'exemple précédent, l'indexation est le
suivant :
#+ATTR_LATEX: :environment tabular :align |l|c|c|c|c|c|c|c|
#+ATTR_LATEX: :center t
#+ATTR_LATEX: :font \footnotesize
| Élément       | ="chocolat"= | =2.0= | =("un tuple dans un tuple", )= | =-1= | =False= | =()= | =1e-3= |
|---------------+--------------+-------+--------------------------------+------+---------+------+--------|
| Index         |            0 |     1 |                              2 |    3 |       4 |    5 |      6 |
|---------------+--------------+-------+--------------------------------+------+---------+------+--------|
| Index négatif |           -7 |    -6 |                             -5 |   -4 |      -3 |   -2 |     -1 |

Toujours de manière analogue aux chaînes de caractères, l'opérateur =[]= permet d'accéder aux
différents éléments du tuple par indexation simple ou par /slicing/. Exemple :
#+attr_latex: :options bgcolor=almostwhite, frame=lines
#+BEGIN_SRC ipython :session :results raw drawer code :exports code
print(un_tuple_heterogene[0])
print(un_tuple_heterogene[4])
print(un_tuple_heterogene[-1])
print(un_tuple_heterogene[::2])
print(un_tuple_heterogene[:-3])
print(un_tuple_heterogene[2:])
#+END_SRC

L'analogie avec les chaînes de caractère se poursuit :
- Les tuples étant immuables, il n'est pas possible de modifier un élément /via/
  l'indexation. Autrement dit, écrire =un_tuple_heterogene[2] = "nouvelle valeur"= renvoie une
  erreur. 
- L'opérateur =+= permet de concaténer deux tuples, e.g. =() + (1, 2) = (1, 2)=.
- L'opérateur =*= permet de répliquer un tuple, e.g. =3*(4,) = (4, 4, 4)=.
- La fonction =len= permet de calculer le nombre d'éléments d'un tuple.

Il est enfin possible de trier un tuple avec la fonction =sorted=[fn:: En fait, la fonction =sorted=
fonctionne également pour les chaînes de caractères ! N'hésitez pas à tester.] : 
#+attr_latex: :options bgcolor=almostwhite, frame=lines
#+BEGIN_SRC ipython :session :results raw drawer code :exports code
scores = (5, 5, 3, 4, 1, 4, 3, 4, 5, 2)
scores_tries = sorted(scores)
#+END_SRC
Par défaut, la fonction =sorted= effectue un tri dans l'ordre croissant du tuple passé en argument
et renvoie un nouveau tuple trié. À noter que la fonction =sorted= ne pourra fonctionner que s'il
existe une relation d'ordre entre les éléments du tuple sinon une erreur sera renvoyée.

_Exercice :_

- Comment accéder à la chaîne de caractère ="un tuple dans un tuple"= à partir du tuple
  =un_tuple_heterogene= ? 
- Quelle est le nombre d'éléments du tuple =un_tuple_heterogene= ?
- Trier la liste =scores= dans l'ordre décroissant ? (regarder l'aide de la fonction =sorted=)

Solution :
#+attr_latex: :options bgcolor=black, style=bw, frame=lines
#+BEGIN_SRC ipython :session :results raw drawer code :exports code
print(un_tuple_heterogene[2][0])
print(f"Longeur du tuple = {len(un_tuple_heterogene)}")
scores_decroissants = sorted(scores, reverse=True)
print(scores_decroissants)
#+END_SRC


* Les listes

** Analogies et différences par rapport aux tuples

Les listes sont des séquences d'éléments ordonnées *modifiables* (on parle d'objets muables en =Python=). Le rôle des listes
est - comme celui des les tuples - de stocker des éléments. Cependant, la différence majeure
provient du fait que la structure d'une liste peut changer au cours de l'exécution d'un
programme. Autrement dit, il est possible de changer la structure d'une liste en ajoutant, en supprimant et en
modifiant des éléments sans créer une nouvelle liste.

Pour définir une liste, il faut préciser ses éléments en les séparant par des virgules à l'intérieur de
crochets :
#+attr_latex: :options bgcolor=almostwhite, frame=lines
#+BEGIN_SRC ipython :session :results raw drawer code :exports code
liste_scores = [5, 5, 3, 4, 1, 4, 3, 4, 5, 2]
liste_melange = ["chocolat", 2.0, ("un tuple dans un tuple", ),\
                 -1, False, [], 1e-3]
#+END_SRC

Toutes les fonctionnalités présentées pour les tuples sont applicables 
aux listes, sauf en ce qui concerne les points suivants :
- Le type des listes est =list=.
- La liste vide s'écrit =[]=.
- La liste a un élément s'écrit de manière intuitive =[<mon_element>]=.
- Il est possible de modifier un élément d'une liste par indexation, e.g. =liste_melange[0] =
  ["a","b","c"]=

_Pratique :_

- Testez les fonctions =sorted= et =len= dans le cas des listes.
- Réalisez quelques opérations de /slicing/ afin de vous convaincre de leur analogie avec les tuples
  et les chaînes de caractères.
- Testez les opérateurs =+= et =*= dans le cas des listes.

** Méthodes spécifiques

Les listes sont des objets =Python= possédant un certain nombre de méthodes particulières
permettant, notamment, de modifier leur structure interne. Cette section couvre quelques méthodes
usuelles sans pour autant prétendre à l'exhaustivité. N'hésitez donc pas à parcourir l'aide sur les
listes afin de découvrir d'autres méthodes bien utiles.

*** Méthode =append=

La méthode =append= ajoute un élément à la fin de la liste qui appelle la méthode. La
modification est faite sur place (/in place/ en anglais) ce qui signifie que la liste est modifiée
après exécution de la méthode. Par exemple :
#+attr_latex: :options bgcolor=almostwhite, frame=lines
#+BEGIN_SRC ipython :session :results raw drawer code :exports code
notes_eleves = [18, 19, 19, 17, 18]
notes_eleves.append(16)
print(notes_eleves)
#+END_SRC
À noter que nous pouvons aboutir au même résultat avec le code suivant :
#+attr_latex: :options bgcolor=almostwhite, frame=lines
#+BEGIN_SRC ipython :session :results raw drawer code :exports code
notes_eleves = [18, 19, 19, 17, 18]
notes_eleves = notes_eleves + [16]
print(notes_eleves)
#+END_SRC

_Remarque geek :_

La différence entre les deux approches précédentes se situe essentiellement au niveau des
  performances informatiques. En effet, l'approche utilisant l'opérateur de concaténation est plus
  coûteuse en temps de calcul car cette dernière implique la création d'une nouvelle liste contenant le
  résultat, et ce, contrairement à la méthode =append= qui modifie simplement la liste existante.

Pour vous en convaincre, vous pouvez utiliser la commande magique =Jupyter= =%%timit= pour évaluer
le temps d'exécution de code =Python= :
#+attr_latex: :options bgcolor=almostwhite, frame=lines
#+BEGIN_SRC ipython :session :results raw drawer code :exports code
%%timeit
notes_eleves = [18, 19, 19, 17, 18]
notes_eleves.append(16)
#+END_SRC
#+attr_latex: :options bgcolor=almostwhite, frame=lines
#+BEGIN_SRC ipython :session :results raw drawer code :exports code
%%timeit
notes_eleves = [18, 19, 19, 17, 18]
notes_eleves = notes_eleves + [16]
#+END_SRC

Il est important de retenir que les commandes magiques =Jupyter= ne sont pas connues du langage
=Python= standard. Elles sont souvent très pratiques mais ne fonctionnent que dans l'environnement
=Jupyter=. Il ne faut donc limiter leur utilisation aux /notebooks/ et dans des cas bien particuliers.

*** Méthode =extend=

La méthode =extend= concatène une liste à la fin de la liste qui appelle la méthode. De la
même façon que pour la méthode =append=, la modification est faite sur place. Par exemple :
#+attr_latex: :options bgcolor=almostwhite, frame=lines
#+BEGIN_SRC ipython :session :results raw drawer code :exports code
notes_eleves = [18, 19, 19, 17, 18]
notes_eleves.extend([20, 12])
print(notes_eleves)
#+END_SRC
Notons que l'argument de la méthode =extend= doit être de type =list= ou pour être tout à fait exact
un objet "itérable"[fn:: Les "itérables" constituent une famille d'objets regroupant notamment les
listes, tuples, dictionnaires, chaînes de caractères et les ensembles. Nous reviendrons sur cette
notion ultérieurement.].

La remarque sur geek sur les performances de la méthode =append= est applicable dans le cas de la méthode =extend=.

*** Méthode =pop=

La méthode =pop= supprime sur place un élément de la liste. Par exemple :
#+attr_latex: :options bgcolor=almostwhite, frame=lines
#+BEGIN_SRC ipython :session :results raw drawer code :exports code
notes_eleves = [18, 19, 19, 17, 18]
notes_eleves.pop(1)
print(notes_eleves)
#+END_SRC

Voici quelques remarques sur la méthode =pop= : 
- La méthode =pop= appelée sans argument, e.g. =notes_eleves.pop()=, supprime par défaut le dernier
  élément de la liste.
- La méthode =pop= fonctionne avec l'indexation négative, e.g. =notes_eleves.pop(-2)= supprime
  l'avant dernier élément de la liste.
- La méthode =pop= renvoie l'élément supprimé. Il est donc possible d'écrire =elt =
  notes_eleves.pop(0)=. Dans ce cas, la variable =elt= prend la valeur de l'ex-premier élément de
  la liste qui vient d'être supprimé.

#+LATEX: \

_Exercice :_

- Il existe une méthode =remove= pour les objets de type =list=, quelles sont ses différences avec
  la méthode =pop= ?  
- Il existe également une fonction =del=, comparez son utilisation par rapport aux méthodes =pop= et
  =remove=.

Solution :
#+attr_latex: :options bgcolor=black, style=bw, frame=lines
#+BEGIN_SRC ipython :session :results raw drawer code :exports code
# La méthode remove supprime un élément de la liste à partir de sa valeur
# contrairement à pop qui supprime une valeur à partir d'un indice
notes_eleves = [18, 19, 19, 17, 18]
notes_eleves.remove(18)
print(notes_eleves)
#+END_SRC
#+attr_latex: :options bgcolor=black, style=bw, frame=lines
#+BEGIN_SRC ipython :session :results raw drawer code :exports code
# La fonction del est une fonction native Python permettant de supprimer
# des éléments par indexation avancée (slicing). Attention sa syntaxe 
# n'est pas usuelle pour Python 3. Il est préférable d'utiliser la méthode
# pop à la place. 
notes_eleves = [18, 19, 19, 17, 18]
del notes_eleves[1::2]
print(notes_eleves)
#+END_SRC

** Conversion d'une chaîne de caractères en liste

Les listes ayant été introduites, nous pouvons revenir aux objets de type =str= (chaîne de
caractères) afin de présenter la méthode =split=. Cette méthode permet de convertir une chaîne de
caractères en liste de chaînes de caractères sur la base d'un séparateur donné. Voici quelques
exemples :
#+attr_latex: :options bgcolor=almostwhite, frame=lines
#+BEGIN_SRC ipython :session :results raw drawer code :exports code
texte_fruits = "banane poire pomme"
liste_fruits = texte_fruits.split(" ")
print(liste_fruits)
#+END_SRC
#+attr_latex: :options bgcolor=almostwhite, frame=lines
#+BEGIN_SRC ipython :session :results raw drawer code :exports code
texte_fruits = "banane;poire;pomme"
liste_fruits = texte_fruits.split(";")
print(liste_fruits)
#+END_SRC
#+attr_latex: :options bgcolor=almostwhite, frame=lines
#+BEGIN_SRC ipython :session :results raw drawer code :exports code
texte_fruits = "banane||poire||pomme"
liste_fruits = texte_fruits.split("||")
print(liste_fruits)
#+END_SRC

_Exercice :_
Étudier l'aide de la méthode =join= du type =str= afin de réaliser l'opération inverse de =split=, à
savoir transformer une liste de chaînes de caractères en chaîne de caractères dans laquelle les
termes sont séparés par un séparateur donné.

Solution
#+attr_latex: :options bgcolor=black, style=bw, frame=lines
#+BEGIN_SRC ipython :session :results raw drawer code :exports code
" ".join(liste_fruits)
#+END_SRC
#+attr_latex: :options bgcolor=black, style=bw, frame=lines
#+BEGIN_SRC ipython :session :results raw drawer code :exports code
";".join(liste_fruits)
#+END_SRC
#+attr_latex: :options bgcolor=black, style=bw, frame=lines
#+BEGIN_SRC ipython :session :results raw drawer code :exports code
"||".join(liste_fruits)
#+END_SRC

* Les dictionnaires

** Définition
À la différence des listes ou tuples qui sont indexées par des index numériques commençant à 0, les
dictionnaires laissent une bien plus grande liberté. Nous allons en effet pouvoir choisir notre
indexation (on parlera de clés) et attribuer la clé de notre choix à chaque valeur présente dans le
dictionnaire. La seule contrainte est d'assurer que toutes les clés sont uniques et immuables (comme toute
indexation qui se respecte). En conséquence, il n'y a pas de notion d'ordre dans l'indexation d'un
dictionnaire. 

Pour créer un nouveau dictionnaire, il faut définir les paires =clé : valeur= à l'intérieur
d'accolades ={}= comme ceci : 
#+attr_latex: :options bgcolor=almostwhite, frame=lines
#+BEGIN_SRC ipython :session :results raw drawer code :exports code
joueur_equipe = {
    "Kawhi Leonard": "LA Clippers",
    "Lebron James": "LA Lakers",
    "Rudy Gobert": "Chicago Bulls",
    "Evan Fournier": "Orlando Magic"
}
#+END_SRC

Sur l'exemple précédent, le système d'indexation par clé/valeur est le suivant :
# #+ATTR_LATEX: :environment tabular :align |l|c|c|c|c|c|c|c|
# #+ATTR_LATEX: :center t
# #+ATTR_LATEX: :font \footnotesize
# |--------+-------------------+------------------+-------------------+-------------------|
# | Clé    | ="Kawhi Leonard"= | ="Lebron James"= | ="Rudy Gobert"=   | ="Evan Fournier"= |
# |--------+-------------------+------------------+-------------------+-------------------|
# | Valeur | ="LA Clippers"=   | ="LA Lakers"=    | ="Chicago Bulls"= | ="Orlando Magic"= |
# |--------+-------------------+------------------+-------------------+-------------------|

L'opérateur =[]= permet une fois de plus d'accéder aux éléments du dictionnaire à partir de leur clé. Exemple :
#+attr_latex: :options bgcolor=almostwhite, frame=lines
#+BEGIN_SRC ipython :session :results raw drawer code :exports code
joueur_equipe["Kawhi Leonard"]
#+END_SRC

Les dictionnaires étant muables (modifiables), l'opérateur =[]= permet également de modifier une
valeur à partir de sa clé :
#+attr_latex: :options bgcolor=almostwhite, frame=lines
#+BEGIN_SRC ipython :session :results raw drawer code :exports code
joueur_equipe["Rudy Gobert"] = "Utah Jazz"
#+END_SRC

Il est également possible d'ajouter un nouveau couple de clé/valeur à un dictionnaire avec l'opérateur
=[]=. Pour ce faire, il suffit simplement d'affecter une valeur à une clé qui n'existe pas encore
dans le dictionnaire pour l'ajouter :
#+attr_latex: :options bgcolor=almostwhite, frame=lines
#+BEGIN_SRC ipython :session :results raw drawer code :exports code
joueur_equipe["Nicolas Batum"] = "Charlotte Hornets"
#+END_SRC

_Remarques :_
- Le type des dictionnaire est =dict=. 
- Le dictionnaire vide est noté ={}=.
- Les clés d'un dictionnaire ne sont pas nécessairement de même type du moment qu'elles sont
  immuables (e.g. entier, flottant, booléen, tuples, etc).
- Les valeurs d'un dictionnaire peuvent être quelconques et de structure arbitraire. 

Voici par exemple, un dictionnaire dont la structure est assez complexe et contre intuitive mais
tout à fait valide : 
#+attr_latex: :options bgcolor=almostwhite, frame=lines
#+BEGIN_SRC ipython :session :results raw drawer code :exports code
dico = {"clé_1": {"a": 1, ("t1", "t2"): 1.3}, -10: [1, 3, 4]}
#+END_SRC

** Méthodes usuelles

Le type =dict= dispose des principales méthodes suivantes :
- =get= : accède à un élément à partir d'une clé.
- =setdefault= : associe une valeur à une clé si cette dernière n'existe pas déjà.
- =pop= : supprime un élément à partir d'une clé.
- =keys= : renvoie un "itérateur" sur les clés du dictionnaire.
- =values= : renvoie un "itérateur" sur les valeurs du dictionnaire.
- =items= : renvoie un "itérateur" sur les couples (clé, valeur) du dictionnaire.

Utilisez l'aide pour comprendre le fonctionnement des méthodes précédentes et testez sur des
exemples. 

_Remarque :_
Nous n'avons pas encore vu la notion d'"itérateur". Pour faire simple, les itérateurs sont des
objets contenant des informations (listes, tuples, dictionnaires, chaînes de caractères, etc) qui
peuvent être convertis en liste avec la fonction =list=. 

_Exercice :_
- Quel est la différence entre la méthode =get= et l'utilisation de l'opérateur =[]= ?

Solution :
#+attr_latex: :options bgcolor=black, style=bw, frame=lines
#+BEGIN_SRC ipython :session :results raw drawer code :exports code
# La méthode get permet d'accéder à une clé d'un dictionnaire 
# et de renvoyer la valeur None si cette dernière n'existe pas.
# Contrairement a l'utilisation de [] qui renvoie une erreur si la clé
# n'existe pas.
val = joueur_equipe.get("Larry Bird")
print(f"val = {val} car 'Larry Bird' n'est pas une clé du dictionnaire")

# L'utilisateur peut préciser la valeur par défaut retourner par get
# si la clé n'existe pas.
val = joueur_equipe.get("Larry Bird", "Clé absente")
print(f"val = {val} car 'Larry Bird' n'est pas une clé du dictionnaire")
#+END_SRC

* Les ensembles

** Définition

Les ensembles sont des collections d'éléments :
- non ordonnée ;
- sans indexation ;
- sans doublon, i.e. il ne peut pas y avoir deux fois le même élément.
 
Une des utilisations les plus courantes des ensembles est la suppression des doublons dans d'autres
types de collection de données (e.g. listes). Il est également pratique d'utiliser ce type de
structure pour réaliser des opérations d'intersection, d'union et de différence sur des collections 
d'objets. 

Pour créer un ensemble, nous utilisons une paire d'accolades ={}= en séparant les différents
éléments de l'ensemble par une virgule :
#+attr_latex: :options bgcolor=almostwhite, frame=lines
#+BEGIN_SRC ipython :session :results raw drawer code :exports code
un_ensemble = {"a", "b", 3, "c", 3, "a", 10}
print(un_ensemble)
#+END_SRC
Cette exemple illustre la suppression des doublons dans un ensemble.

_Remarque :_

L'ensemble vide s'obtient avec un appel à la fonction =set()=, l'utilisation de ={}= conduisant à la
création d'un dictionnaire vide.

** Méthodes usuelles

Le type =set= dispose des principales méthodes suivantes :
- =add= : ajoute un élément à l'ensemble.
- =remove= : supprime un élément à partir d'une valeur.
- =pop= : supprime un élément de manière arbitraire dans l'ensemble.
- =issubset= : test si l'ensemble est inclus dans un autre.
- =issuperset= : test si l'ensemble englobe un autre.
- =intersection= : calcul l'intersection de l'ensemble avec un autre.
- =union= : calcul l'union de l'ensemble avec un autre.

#+LATEX: \
Utilisez l'aide pour comprendre le fonctionnement des méthodes précédentes et testez sur des
exemples.  

* Conversion d'une collection vers une autre

Il existe des possibilités de conversion entre tuples, listes, dictionnaires et ensembles. Pour ce
faire, il faut appeler le constructeur de chaque structure sur la collection à convertir :
- =tuple(<coll>)= va tenter de convertir =<coll>= en tuple ;
- =list(<coll>)= va tenter de convertir =<coll>= en liste ;
- =dict(<coll>)= va tenter de convertir =<coll>= en dictionnaire ;
- =set(<coll>)= va tenter de convertir =<coll>= en ensemble.

#+LATEX: \

_Pratique :_
Définissez un tuple, une liste, un dictionnaire et un ensemble et essayez de déterminer les règles
de conversion entre ces types de collections. 

_Exercice :_

Écrire une ligne de code permettant de calculer une liste sans doublon à partir d'une liste
quelconque. 

Solution :
#+attr_latex: :options bgcolor=black, style=bw, frame=lines
#+BEGIN_SRC ipython :session :results raw drawer code :exports code
liste_avec_doublons = [1,2,3,3,2,0]
ensemble_sans_doublon = set(liste_avec_doublons)
liste_sans_doublon = list(ensemble_sans_doublon)
#+END_SRC

* L'affectation par référence

# TODO: mettre un petit schéma un jour

Il est temps d'aborder un point souvent difficile à appréhender (disons potentiellement déroutant)
lors des premiers pas avec =Python=. 

En effet, quand on utilise le signe === pour réaliser une affectation d'une valeur à une variable,
l'opération réellement effectuée est en fait la déclaration d'une référence. Plus concrètement,
quand nous écrivons :
#+attr_latex: :options bgcolor=almostwhite, frame=lines
#+BEGIN_SRC ipython :session :results raw drawer code :exports code
liste1 = [1, 2, 3, 4]
#+END_SRC
Cela signifie que la variable =liste1= est une référence vers l'objet liste =[1,2,3,4]=.

Par la suite, si nous affectons notre première variable dans une seconde variable comme suit :
#+attr_latex: :options bgcolor=almostwhite, frame=lines
#+BEGIN_SRC ipython :session :results raw drawer code :exports code
liste2 = liste1
#+END_SRC
Dans ce cas, cela signifie que =liste1= et =liste2= partagent la même référence vers l'objet
=[1,2,3,4]=. Par conséquent, si nous modifions notre liste =[1,2,3,4]= /via/ la variable =liste2= :
#+attr_latex: :options bgcolor=almostwhite, frame=lines
#+BEGIN_SRC ipython :session :results raw drawer code :exports code
liste2[2] = "boum"
#+END_SRC
Nous constatons qu'en affichant l'objet référencé par =liste1=, le troisième élément est bien
égal à ="boum"= :  
#+attr_latex: :options bgcolor=almostwhite, frame=lines
#+BEGIN_SRC ipython :session :results raw drawer code :exports code
print(liste1)
#+END_SRC
Pour résumer, il ne faut pas considérer le signe === comme un opérateur de copie. Notons au passage
que l'exemple précédent s'applique aux objets muables en général et donc en particulier aux dictionnaires.

_Remarque :_

En pratique, nous constatons qu'il y a souvent une alternative à la copie d'un
objet. Toutefois, chaque type dispose en théorie d'une méthode ou d'une fonction pour copier un
objet. Par exemple, les types =list=, =dict= ou =set= possèdent la méthode =copy= permettant de
réaliser cette opération[fn:: La copie d'objet en =Python= reste un sujet non trivial. Voir
[[https://docs.python.org/fr/2.7/library/copy.html]] pour en
savoir plus.].


