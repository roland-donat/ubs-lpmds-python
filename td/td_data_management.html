<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="fr" xml:lang="fr">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Data management et premières analyses descriptives avec =Pandas=</title>
<meta name="author" content="Roland Donat" />
<meta name="generator" content="Org Mode" />
<link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/css/htmlize.css"/>
<link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/css/readtheorg.css"/>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/lib/js/jquery.stickytableheaders.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/js/readtheorg.js"></script>
<link rel="stylesheet" type="text/css" href="https://roland-donat.github.io/ubs/Charte_graphique/IUT/ubs_iut_vannes.css" />
<link rel="stylesheet" type="text/css" href="https://roland-donat.github.io/ubs-lpmds-python/custom.css" />
</head>
<body>
<div id="content" class="content">
<h1 class="title">Data management et premières analyses descriptives avec <code>Pandas</code></h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table des matières</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org630bb8c">1. Contexte et objectif</a></li>
<li><a href="#org7e9ef9d">2. Données historiques</a>
<ul>
<li><a href="#org4075639">2.1. Présentation des données</a></li>
<li><a href="#orgc2cc34b">2.2. Chargement des données</a></li>
</ul>
</li>
<li><a href="#orgdc2de45">3. Notions de <code>DataFrame</code> et <code>Series</code></a></li>
<li><a href="#orgdea3657">4. Sélection des données</a></li>
<li><a href="#org7a332dc">5. Typage des données</a></li>
<li><a href="#org678a138">6. Traitement des données manquantes</a></li>
<li><a href="#orgf73ffb0">7. Premières analyses descriptives</a></li>
</ul>
</div>
</div>






<div id="org0f5e385" class="figure">
<p><img src="https://www.agent-x.com.au/wp-content/uploads/2011/06/Perfect-Programmer-dfe194b-e8d3b11-b960bd5.jpg" alt="Perfect-Programmer-dfe194b-e8d3b11-b960bd5.jpg" />
</p>
</div>


<div id="outline-container-org630bb8c" class="outline-2">
<h2 id="org630bb8c"><span class="section-number-2">1.</span> Contexte et objectif</h2>
<div class="outline-text-2" id="text-1">
<p>
Quelle est la probabilité pour Lorient de vaincre Paris en Ligue 1 compte tenu des joueurs prévus
pour la rencontre ? Une star est blessée, quel impact cela aura t-il sur la probabilité de victoire
de votre équipe préférée ?    
</p>

<p>
L'industrie du sport est un secteur saturé de statistiques et de données. Pourtant, la
généralisation de l'utilisation de la <i>data science</i> pour l'analyse sportive est une pratique
relativement récente. 
</p>

<p>
Dans ce TD et les suivants, nous allons commencer le développement d'un algorithme de pronostics pour les matchs de football. Ce travail repose sur l'exploitation de données historiques 
de différents championnats européens ainsi que sur les cotes proposées par quelques
bookmakers. Le développement complet d'un tel outil nécessite la réalisation des tâches suivantes :
</p>
<ol class="org-ol">
<li>Préparation des données et premières analyses exploratoires.</li>
<li>Analyse descriptive et visualisation.</li>
<li>Construction d'indicateurs.</li>
<li>Modélisation prévisionnelle et évaluation des performances.</li>
</ol>

<p>
Ce TD porte en particulier sur le premier point.
</p>

<p>
<b>Rappels :</b>
</p>
<ul class="org-ul">
<li>Créez un <i>notebook</i> dans le lequel vous allez écrire, exécuter et documenter votre code <code>Python</code>.</li>
<li>Prenez le temps de bien présenter et bien rédiger votre <i>notebook</i>.</li>
</ul>
</div>
</div>


<div id="outline-container-org7e9ef9d" class="outline-2">
<h2 id="org7e9ef9d"><span class="section-number-2">2.</span> Données historiques</h2>
<div class="outline-text-2" id="text-2">
</div>
<div id="outline-container-org4075639" class="outline-3">
<h3 id="org4075639"><span class="section-number-3">2.1.</span> Présentation des données</h3>
<div class="outline-text-3" id="text-2-1">
<p>
Les données historiques, référencées dans la suite par données <code>fixtures</code>, contiennent un historique
 de matchs sur différents championnats. Le Tableau <a href="#orga5da26e">1</a> présente
 une description succintes des variables présentes.
</p>

<table id="orga5da26e" border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Tableau 1 :</span> Définition des variables du jeu de données <code>fixtures</code>.</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Colonne</th>
<th scope="col" class="org-left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">league_id</td>
<td class="org-left">Identifiant du championnat</td>
</tr>

<tr>
<td class="org-left">season_id</td>
<td class="org-left">Identifiant de la saison</td>
</tr>

<tr>
<td class="org-left">Date</td>
<td class="org-left">Date du match au format %Y-%m-%d</td>
</tr>

<tr>
<td class="org-left">HomeTeam</td>
<td class="org-left">Équipe à domicile (ED)</td>
</tr>

<tr>
<td class="org-left">AwayTeam</td>
<td class="org-left">Équipe à l'exterieur (EE)</td>
</tr>

<tr>
<td class="org-left">FTHG</td>
<td class="org-left">Nombre de buts de l'ED à la fin du match</td>
</tr>

<tr>
<td class="org-left">FTAG</td>
<td class="org-left">Nombre de buts de l'EE à la fin du match</td>
</tr>

<tr>
<td class="org-left">FTR</td>
<td class="org-left">Résultat à la fin du match (H = ED gagne, D = match nul, A = EE gagne)</td>
</tr>

<tr>
<td class="org-left">HTHG</td>
<td class="org-left">Nombre de buts de l'ED à la mi-temps</td>
</tr>

<tr>
<td class="org-left">HTAG</td>
<td class="org-left">Nombre de buts de l'EE à la mi-temps</td>
</tr>

<tr>
<td class="org-left">HTR</td>
<td class="org-left">Résultat à la mi-temps (H = ED gagne, D = match nul, A = EE gagne)</td>
</tr>

<tr>
<td class="org-left">HS</td>
<td class="org-left">Nombre de tirs tentés par l'ED</td>
</tr>

<tr>
<td class="org-left">AS</td>
<td class="org-left">Nombre de tirs tentés par l'EE</td>
</tr>

<tr>
<td class="org-left">HST</td>
<td class="org-left">Nombre de tirs cadrés par l'ED</td>
</tr>

<tr>
<td class="org-left">AST</td>
<td class="org-left">Nombre de tirs cadrés par l'EE</td>
</tr>

<tr>
<td class="org-left">HY</td>
<td class="org-left">Nombre de cartons jaunes reçus par l'ED</td>
</tr>

<tr>
<td class="org-left">AY</td>
<td class="org-left">Nombre de cartons jaunes reçus par l'EE</td>
</tr>

<tr>
<td class="org-left">HR</td>
<td class="org-left">Nombre de cartons rouges reçus par l'ED</td>
</tr>

<tr>
<td class="org-left">AR</td>
<td class="org-left">Nombre de cartons rouges reçus par l'EE</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="outline-container-orgc2cc34b" class="outline-3">
<h3 id="orgc2cc34b"><span class="section-number-3">2.2.</span> Chargement des données</h3>
<div class="outline-text-3" id="text-2-2">
<p>
Nous allons tout d'abord charger les données <code>fixtures</code> dans notre environnement
<code>Python</code> en utilisant la librairie <code>Pandas</code>.
Ces données sont accessibles <i>via</i> les liens suivants :
</p>


<p>
<b>Travail à réaliser :</b>
</p>
<ol class="org-ol">
<li><p>
Importer la librairie <code>pandas</code> dans votre environnement.
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">import</span> pandas <span style="color: #F0DFAF; font-weight: bold;">as</span> pd
</pre>
</div></li>

<li><p>
Afficher la version de la librairie <code>pandas</code> utilisée.
</p>
<div class="org-src-container">
<pre class="src src-python">f<span style="color: #9FC59F;">"Pandas : {pd.__version__}"</span>
</pre>
</div></li>

<li><p>
Utiliser la méthode <code>Pandas</code> <code>.read_csv</code> afin de lire les données directement depuis ce lien :
<a href="https://roland-donat.github.io/ubs-lpmds-python/td/data/fixtures.csv.bz2">https://roland-donat.github.io/ubs-lpmds-python/td/data/fixtures.csv.bz2</a>
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">fixtures_url</span> = <span style="color: #CC9393;">"https://roland-donat.github.io/ubs-lpmds-python/td/data/fixtures.csv.bz2"</span>
<span style="color: #DFAF8F;">fixtures_df</span> = pd.read_csv(fixtures_url, sep=<span style="color: #CC9393;">";"</span>, compression=<span style="color: #CC9393;">"bz2"</span>)
</pre>
</div>
<p>
Note : Les données sont sépérées par des points-virgules et compressées en <code>bzip2</code>. Il faut donc penser
à utiliser les arguments <code>sep</code> et <code>compression</code> afin de tenir compte de ces deux éléments.
</p></li>

<li><p>
Utiliser les méthodes <code>.head</code>, <code>.info</code> et <code>.describe</code> afin d'avoir un aperçu des données chargées.
</p>
<div class="org-src-container">
<pre class="src src-python">fixtures_df.head()
</pre>
</div>
<div class="org-src-container">
<pre class="src src-python">fixtures_df.info()
</pre>
</div>
<div class="org-src-container">
<pre class="src src-python">fixtures_df.describe()
</pre>
</div></li>
</ol>
</div>
</div>
</div>


<div id="outline-container-orgdc2de45" class="outline-2">
<h2 id="orgdc2de45"><span class="section-number-2">3.</span> Notions de <code>DataFrame</code> et <code>Series</code></h2>
<div class="outline-text-2" id="text-3">
<p>
La librairie <code>Pandas</code> travaille principalement avec deux types d'objets :
</p>
<ul class="org-ul">
<li>les tableaux de données appelés <code>DataFrame</code> ;</li>
<li>les vecteurs de données appelés <code>Series</code>.</li>
</ul>

<p>
Un <code>DataFrame</code> est composé :
</p>
<ul class="org-ul">
<li>d'une ou plusieurs colonnes représentant les variables du jeu de données ;</li>
<li>d'une ou plusieurs lignes représentant les individus du jeu de données.</li>
</ul>

<p>
Chaque ligne et chaque colonne d'un <code>DataFrame</code> est donc un vecteur (une seule dimension) mis sous la
forme d'une <code>Series</code>.
</p>


<p>
<b>Travail à réaliser :</b>
</p>
<ol class="org-ol">
<li><p>
Quel est le type de la variable <code>fixtures_df</code> ?
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DCDCCC; font-weight: bold;">type</span>(fixtures_df)
</pre>
</div></li>

<li><p>
Dans un <code>DataFrame</code>, chaque valeur est identifiée grâce à un nom de ligne (appelé <code>index</code>) et
un nom de colonne (appelé <code>column</code>). Afficher le nom des lignes et le nom des colonnes des
données <code>fixtures</code> :
</p>
<div class="org-src-container">
<pre class="src src-python">fixtures_df.index
</pre>
</div>
<div class="org-src-container">
<pre class="src src-python">fixtures_df.columns
</pre>
</div></li>

<li><p>
Vous pouvez accéder aux différents éléments d'un <code>DataFrame</code> en utilisant l'attribut <code>.loc</code>. Par
exemple, pour récupérer la colonne <code>HomeTeam</code> :
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">&#201;criture explicite</span>
fixtures_df.loc[:, <span style="color: #CC9393;">"HomeTeam"</span>]
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">&#201;criture implicite</span>
fixtures_df[<span style="color: #CC9393;">"HomeTeam"</span>]
</pre>
</div>
<p>
La commande précédente permet de récupérer toutes les lignes (opérateur <code>:</code>) de la colonne
appelée <code>"HomeTeam"</code>. 
</p>

<p>
De la même manière, on peut accéder à la ligne de label <code>3</code> comme suit :
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">&#201;criture explicite</span>
fixtures_df.loc[3, :]
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">&#201;criture implicite</span>
fixtures_df.loc[3]
</pre>
</div>

<p>
Enfin, vous pouvez accéder à plusieurs lignes et colonnes (sous-tableau) en utilisant des listes
dans l'attribut <code>.loc</code> :
</p>
<div class="org-src-container">
<pre class="src src-python">fixtures_df.loc[3:7, [<span style="color: #CC9393;">"HomeTeam"</span>, <span style="color: #CC9393;">"AwayTeam"</span>]]
</pre>
</div></li>

<li><p>
Sélectionner les 50 premiers matchs en prenant les colonnes du championnat, de la saison, de la
date, des équipes et du score final.
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">SOLUTION</span>
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">--------</span>
fixtures_df.loc[:50, [<span style="color: #CC9393;">"league_id"</span>, <span style="color: #CC9393;">"season_id"</span>, <span style="color: #CC9393;">"Date"</span>, <span style="color: #CC9393;">"HomeTeam"</span>, <span style="color: #CC9393;">"AwayTeam"</span>, <span style="color: #CC9393;">"FTHG"</span>, <span style="color: #CC9393;">"FTAG"</span>]]
</pre>
</div></li>

<li><p>
Quel est le type des objets suivants <code>fixtures_df.loc[:, "league_id"]</code> et
<code>fixtures_df.loc[3]</code> ?
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">SOLUTION</span>
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">--------</span>
<span style="color: #DCDCCC; font-weight: bold;">type</span>(fixtures_df.loc[:, <span style="color: #CC9393;">"league_id"</span>])
<span style="color: #DCDCCC; font-weight: bold;">type</span>(fixtures_df.loc[3])
</pre>
</div></li>

<li><p>
Quelles sont les principales caractéristiques d'un objet de type <code>Series</code> ?
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">SOLUTION</span>
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">--------</span>
<span style="color: #DFAF8F;">game_s</span> = fixtures_df.loc[3, :]
game_s
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">- Les Series ont un attribut .index permettant d'identifier</span>
<span style="color: #5F7F5F;">#   </span><span style="color: #7F9F7F;">chacune des valeurs de la Series. En revanche, contrairement aux DataFrame,</span>
<span style="color: #5F7F5F;">#   </span><span style="color: #7F9F7F;">les Series n'ont pas d'attribut .columns.</span>
game_s.index
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">- Les Series ont optionnellement un nom accessible avec l'attribut .name</span>
game_s.name
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">- On acc&#232;de aux valeurs d'une Series avec l'attribut .loc mais avec une seule dimension</span>
game_s.loc[[<span style="color: #CC9393;">"Date"</span>, <span style="color: #CC9393;">"HomeTeam"</span>, <span style="color: #CC9393;">"FTHG"</span>]]
</pre>
</div></li>

<li><p>
Il est possible de changer l'index d'un <code>DataFrame</code> avec la méthode <code>set_index</code>. Par exemple, on
peut créer un nouveau <code>DataFrame</code> dans lequel les colonnes <code>"HomeTeam"</code> et <code>"AwayTeam"</code> sont
utilisées en tant qu'index :
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">fixtures_2_df</span> = fixtures_df.set_index([<span style="color: #CC9393;">"HomeTeam"</span>, <span style="color: #CC9393;">"AwayTeam"</span>])
fixtures_2_df
</pre>
</div>
<p>
On obtient ainsi un index multidimensionnel. Les lignes du <code>DataFrame</code> <code>fixtures_bis_df</code> sont maintenant
identifiées par la valeur d'une équipe à domicile et une équipe à l'extérieure :
</p>
<div class="org-src-container">
<pre class="src src-python">fixtures_2_df.loc[(<span style="color: #CC9393;">"Rennes"</span>, <span style="color: #CC9393;">"Lorient"</span>), :]
</pre>
</div></li>

<li><p>
Créer un nouveau <code>DataFrame</code>, nommé <code>fixtures_3_df</code>, indexé par les colonnes <code>["league_id", "season_id", "Date",
   "HomeTeam", "AwayTeam"]</code>. Quelle est la particularité de cette indexation ?
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">SOLUTION</span>
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">--------</span>
<span style="color: #DFAF8F;">fixtures_3_df</span> = fixtures_df.set_index([<span style="color: #CC9393;">"league_id"</span>, <span style="color: #CC9393;">"season_id"</span>, <span style="color: #CC9393;">"Date"</span>,
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>  <span style="color: #CC9393;">"HomeTeam"</span>, <span style="color: #CC9393;">"AwayTeam"</span>])
fixtures_3_df
</pre>
</div></li>

<li><p>
Vous pouvez revenir à l'indexation par défaut, c'est à dire une numérotation des lignes à partir
de 0 avec la méthode <code>.reset_index</code> :
</p>
<div class="org-src-container">
<pre class="src src-python">fixtures_3_df.reset_index()
</pre>
</div></li>
</ol>
</div>
</div>

<div id="outline-container-orgdea3657" class="outline-2">
<h2 id="orgdea3657"><span class="section-number-2">4.</span> Sélection des données</h2>
<div class="outline-text-2" id="text-4">
<p>
Au cours de vos analyses, vous ressentirez probablement vite le besoin de filtrer les données
en fonction des valeurs prises par certaines colonnes. Pour ce faire, il suffit d'utiliser les
opérateurs de comparaison <code>Python</code> appliqués aux colonnes d'un <code>DataFrame</code>. 
</p>

<p>
<b>Travail à réaliser :</b>
</p>
<ol class="org-ol">
<li><p>
Nous allons commencer par récupérer tous les matchs joués à l'extérieur par l'équipe de
Lorient. Pour ce faire il faut dans un premier temps créer une <code>Series</code> booléenne (c'est-à-dire
dont les valeurs sont <code>True</code> ou <code>False</code>) permettant de repérer les matchs qui nous intéressent :
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">condition</span> = fixtures_df[<span style="color: #CC9393;">"AwayTeam"</span>] == <span style="color: #CC9393;">"Lorient"</span>
</pre>
</div>
<p>
La <code>Serie</code> <code>condition</code> contient la valeur <code>True</code> lorsque la colonne <code>"AwayTeam"</code>
vaut <code>"Lorient"</code> et <code>False</code> sinon.
</p>

<p>
Il suffit ensuite d'utiliser cette <code>Series</code> afin de récupérer les lignes du <code>DataFrame</code>
<code>fixtures_df</code> pour lesquelles la condition est vraie. Deux syntaxes sont possibles. Une
syntaxe explicite (recommandée) utilise l'attribut <code>.loc</code> :
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">fixtures_lorient_df</span> = fixtures_df.loc[condition]
fixtures_lorient_df
</pre>
</div>
<p>
Et une syntaxe implicite équivalente :
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">fixtures_lorient_bis_df</span> = fixtures_df[condition]
fixtures_lorient_bis_df
</pre>
</div></li>

<li><p>
Extraire les matchs au cours desquels l'équipe à domicile a réussi au moins 20 tirs cadrés
(colonne <code>HST</code>) en utilisant l'opérateur <code>&gt;=</code>. 
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">SOLUTION</span>
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">--------</span>
<span style="color: #DFAF8F;">condition</span> = fixtures_df[<span style="color: #CC9393;">"HST"</span>] &gt;= 20
fixtures_df.loc[condition]
</pre>
</div></li>

<li><p>
Il est possible de construire des conditions plus complexes en utilisant les opérateurs booléens
de <code>Pandas</code> : <code>&amp;</code> (ET logique) <code>|</code> (OU logique) et <code>~</code> (NON logique). Par exemple, nous pouvons obtenir les
matchs au cours desquels l'équipe à domicile mène à la mi-temps et perd à la fin du match :
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">condition_mi_temps</span> = fixtures_df[<span style="color: #CC9393;">"HTR"</span>] == <span style="color: #CC9393;">"H"</span>
<span style="color: #DFAF8F;">condition_fin</span> = fixtures_df[<span style="color: #CC9393;">"FTR"</span>] == <span style="color: #CC9393;">"A"</span>
fixtures_df.loc[condition_mi_temps &amp; condition_fin]
</pre>
</div></li>

<li><p>
Extraire les matchs perdus à domicile par les joueurs de Lorient alors qu'ils ont réussi
strictement plus de tirs cadrés que leur adversaire.
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">SOLUTION</span>
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">--------</span>
<span style="color: #DFAF8F;">condition_lorient_dom</span> = fixtures_df[<span style="color: #CC9393;">"HomeTeam"</span>] == <span style="color: #CC9393;">"Lorient"</span>
<span style="color: #DFAF8F;">condition_tir_dom</span> = fixtures_df[<span style="color: #CC9393;">"HST"</span>] &gt; fixtures_df[<span style="color: #CC9393;">"AST"</span>]
<span style="color: #DFAF8F;">condition_ftr_dom</span> = fixtures_df[<span style="color: #CC9393;">"FTR"</span>] == <span style="color: #CC9393;">"A"</span>
fixtures_df.loc[condition_lorient_dom &amp; condition_tir_dom &amp; condition_ftr_dom]
</pre>
</div></li>

<li><p>
Extraire à présent <b>tous les matchs</b> perdus par les joueurs de Lorient alors qu'ils ont réussi
strictement plus de tirs cadrés que leur adversaire.
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">SOLUTION</span>
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">--------</span>
<span style="color: #DFAF8F;">condition_lorient_dom</span> = fixtures_df[<span style="color: #CC9393;">"HomeTeam"</span>] == <span style="color: #CC9393;">"Lorient"</span>
<span style="color: #DFAF8F;">condition_tir_dom</span> = fixtures_df[<span style="color: #CC9393;">"HST"</span>] &gt; fixtures_df[<span style="color: #CC9393;">"AST"</span>]
<span style="color: #DFAF8F;">condition_ftr_dom</span> = fixtures_df[<span style="color: #CC9393;">"FTR"</span>] == <span style="color: #CC9393;">"A"</span>
<span style="color: #DFAF8F;">condition_dom</span> = condition_lorient_dom &amp; condition_tir_dom &amp; condition_ftr_dom

<span style="color: #DFAF8F;">condition_lorient_ext</span> = fixtures_df[<span style="color: #CC9393;">"AwayTeam"</span>] == <span style="color: #CC9393;">"Lorient"</span>
<span style="color: #DFAF8F;">condition_tir_ext</span> = fixtures_df[<span style="color: #CC9393;">"AST"</span>] &gt; fixtures_df[<span style="color: #CC9393;">"HST"</span>]
<span style="color: #DFAF8F;">condition_ftr_ext</span> = fixtures_df[<span style="color: #CC9393;">"FTR"</span>] == <span style="color: #CC9393;">"H"</span>
<span style="color: #DFAF8F;">condition_ext</span> = condition_lorient_ext &amp; condition_tir_ext &amp; condition_ftr_ext

fixtures_df.loc[condition_dom | condition_ext]
</pre>
</div></li>

<li><p>
Pour éviter d'enchaîner les opérateurs OU quand il s'agit d'un filtrage sur les valeurs d'une
même colonne, il est commode d'utiliser la méthode pour les <code>Series</code> nommée <code>.isin</code> qui va tester
si chaque donnée de la <code>Series</code> se trouve dans la liste de valeurs passée en argument de la
méthode.
</p>

<p>
Par exemple, le code suivant récupère les matchs des championnats de France :
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">condition</span> = fixtures_df[<span style="color: #CC9393;">"league_id"</span>].isin([<span style="color: #CC9393;">"fra_l2"</span>, <span style="color: #CC9393;">"fra_l1"</span>])
fixtures_df.loc[condition]
</pre>
</div></li>

<li><p>
Extraire les matchs qui ne concernent pas un championnat français.
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">SOLUTION</span>
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">--------</span>
<span style="color: #DFAF8F;">condition_fra</span> = fixtures_df[<span style="color: #CC9393;">"league_id"</span>].isin([<span style="color: #CC9393;">"fra_l2"</span>, <span style="color: #CC9393;">"fra_l1"</span>])
fixtures_df.loc[~condition_fra]
</pre>
</div></li>
</ol>
</div>
</div>


<div id="outline-container-org7a332dc" class="outline-2">
<h2 id="org7a332dc"><span class="section-number-2">5.</span> Typage des données</h2>
<div class="outline-text-2" id="text-5">
<p>
Afin de faciliter le traitement ultérieur des données, il convient de s'assurer que chaque colonne
soit correctement typée. Les principaux types de données reconnus par <code>Pandas</code> sont les entiers (<code>int</code>), les
nombres réels (<code>float</code>), les dates (<code>date</code> ou <code>datetime64</code>), les données qualitatives (<code>category</code>) et
les chaînes de caractères (<code>object</code>).
</p>

<p>
<b>Travail à réaliser :</b>
</p>
<ol class="org-ol">
<li><p>
La variable <code>league_id</code> ne prend qu'un nombre fini de valeurs, c'est donc une variable
qualitative. Il convient de lui assigner le type <code>category</code> comme suit :
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">fixtures_df</span>[<span style="color: #CC9393;">"league_id"</span>] = fixtures_df[<span style="color: #CC9393;">"league_id"</span>].astype(<span style="color: #CC9393;">"category"</span>)
</pre>
</div>
<p>
Une variable de type <code>category</code> dispose d'un attribut spécial <code>.cat</code> apportant, entre autres, des
fonctionnalités telles que :
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Num&#233;risation des modalit&#233;s</span>
fixtures_df[<span style="color: #CC9393;">"league_id"</span>].cat.codes
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">R&#233;cup&#233;ration de la liste des modalit&#233;s</span>
fixtures_df[<span style="color: #CC9393;">"league_id"</span>].cat.categories
</pre>
</div></li>

<li><p>
Transformer les autres variables qualitatives en <code>category</code>.    
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">SOLUTION</span>
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">--------</span>
<span style="color: #DFAF8F;">col_cats</span> = [<span style="color: #CC9393;">"season_id"</span>, <span style="color: #CC9393;">"HomeTeam"</span>, <span style="color: #CC9393;">"AwayTeam"</span>, <span style="color: #CC9393;">"HTR"</span>, <span style="color: #CC9393;">"FTR"</span>]
<span style="color: #F0DFAF; font-weight: bold;">for</span> col <span style="color: #F0DFAF; font-weight: bold;">in</span> col_cats:
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span> <span style="color: #DFAF8F;">fixtures_df</span>[col] = fixtures_df[col].astype(<span style="color: #CC9393;">"category"</span>)
</pre>
</div></li>

<li><p>
Lorsque les modalités sont des labels textuels, les colonnes de type <code>category</code> ont également
accès à l'attribut <code>.str</code> permettant de manipuler les chaînes de caractères. Cet attribut est
également disponible sur les variables de type <code>object</code>. L'attribut <code>.str</code> donne accès à la
plupart des fonctionnalités de traitement des chaînes offertes par <code>Python</code>, e.g. <code>strip</code>,
<code>lower</code>, <code>upper</code>, <code>find</code>, <code>len</code>, etc. Exemple :
</p>
<div class="org-src-container">
<pre class="src src-python">fixtures_df[<span style="color: #CC9393;">"league_id"</span>].<span style="color: #DCDCCC; font-weight: bold;">str</span>.upper()
fixtures_df[<span style="color: #CC9393;">"league_id"</span>].<span style="color: #DCDCCC; font-weight: bold;">str</span>.split(<span style="color: #CC9393;">"_"</span>)
fixtures_df[<span style="color: #CC9393;">"league_id"</span>].<span style="color: #DCDCCC; font-weight: bold;">str</span>.split(<span style="color: #CC9393;">"_"</span>, expand=<span style="color: #BFEBBF;">True</span>)
</pre>
</div></li>

<li><p>
Utiliser la méthode <code>.str.startswith</code> afin d'identifier les matchs des championnats français (à
savoir <code>fra_l1</code> ou <code>fra_l2</code>) et les stocker dans un nouveau <code>DataFrame</code> <code>fixtures_fra_df</code>.
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">SOLUTION</span>
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">--------</span>
<span style="color: #DFAF8F;">idx_fra</span> = fixtures_df[<span style="color: #CC9393;">"league_id"</span>].<span style="color: #DCDCCC; font-weight: bold;">str</span>.startswith(<span style="color: #CC9393;">"fra"</span>)
<span style="color: #DFAF8F;">fixtures_fra_df</span> = fixtures_df.loc[idx_fra]
</pre>
</div></li>

<li><p>
Convertir la colonne <code>Date</code> avec le type <code>"datetime64"</code>.
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">SOLUTION</span>
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">--------</span>
<span style="color: #DFAF8F;">fixtures_df</span>[<span style="color: #CC9393;">"Date"</span>] = fixtures_df[<span style="color: #CC9393;">"Date"</span>].astype(<span style="color: #CC9393;">"datetime64"</span>)
</pre>
</div>
<p>
Les colonnes de type <code>datetime64</code> possèdent un attribut <code>dt</code> apportant des fonctionnalités
permettant de manipuler les dates. Vous pouvez, entre autres, extraire le jour, le mois ou l'année
d'une date :
</p>
<div class="org-src-container">
<pre class="src src-python">fixtures_df[<span style="color: #CC9393;">"Date"</span>].dt.day
fixtures_df[<span style="color: #CC9393;">"Date"</span>].dt.month
fixtures_df[<span style="color: #CC9393;">"Date"</span>].dt.year
</pre>
</div></li>

<li><p>
Identifier les matchs des championnats français ayant eu lieu en 2010 et les stocker dans un nouveau <code>DataFrame</code> <code>fixtures_fra_2010_df</code>.
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">SOLUTION</span>
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">--------</span>
<span style="color: #DFAF8F;">idx_fra</span> = fixtures_df[<span style="color: #CC9393;">"league_id"</span>].<span style="color: #DCDCCC; font-weight: bold;">str</span>.startswith(<span style="color: #CC9393;">"fra"</span>)
<span style="color: #DFAF8F;">idx_2010</span> = fixtures_df[<span style="color: #CC9393;">"Date"</span>].dt.year == 2010
<span style="color: #DFAF8F;">fixtures_fra_2010_df</span> = fixtures_df.loc[idx_fra &amp; idx_2010]
</pre>
</div></li>
</ol>
</div>
</div>

<div id="outline-container-org678a138" class="outline-2">
<h2 id="org678a138"><span class="section-number-2">6.</span> Traitement des données manquantes</h2>
<div class="outline-text-2" id="text-6">
<p>
Les données manquantes dans les <code>DataFrame</code> et les <code>Series</code> sont représentées par le terme <code>NaN</code>
(<i>Not a Number</i>) ou <code>NaT</code> (<i>Not a Time</i>).
</p>

<p>
<b>Travail à réaliser :</b>
</p>
<ol class="org-ol">
<li><p>
Les <code>DataFrame</code> et les <code>Series</code> dispose de la méthode <code>.isnull</code> permettant de repérer les données
manquantes. Le code suivant construit un <code>DataFrame</code> booléen ayant pour valeur <code>True</code> si
l'élément correspondant dans le <code>DataFrame</code> <code>fixtures_df</code> est manquant et <code>False</code> sinon :
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">idx_na_df</span> = fixtures_df.isnull()
idx_na_df
</pre>
</div>

<p>
À partir de ce résultat brut, nous pouvons déduire par exemple le nombre de valeurs manquantes
par colonne avec la méthode <code>.sum</code> :
</p>
<div class="org-src-container">
<pre class="src src-python">idx_na_df.<span style="color: #DCDCCC; font-weight: bold;">sum</span>(axis=0)
</pre>
</div>

<p>
<b>Note 1</b> : L'utilisation de l'argument <code>axis</code> dans la méthode <code>.sum</code> permet d'indiquer sur quelle
dimension est réalisée l'opération de sommation. En indiquant <code>axis=0</code>, cela signifie que les
valeurs du <code>DataFrame</code> sont sommées le long des lignes (<code>index</code>). Avec <code>axis=1</code>, la sommation sera
réalisée le long des colonnes (<code>columns</code>) et donnera donc le nombre de valeurs manquantes de chaque ligne.
</p>

<p>
<b>Note 2</b> : L'argument <code>axis</code> est présent dans de nombreuses méthodes pour <code>DataFrame</code> et
<code>Series</code>. Le mode de fonctionnement est toujours le même : <code>axis=0</code> signifie que l'opération
considérée est faite sur les lignes (<code>index</code>) et <code>axis=1</code> sur les colonnes (<code>columns</code>).
</p>

<p>
<b>Note 3</b> : Lorsque des opérations numériques sur des booléens sont réalisées, <code>Pandas</code> remplace
la valeur <code>True</code> par 1 et la valeur <code>False</code> par 0.
</p></li>

<li><p>
Calculer à présent la proportion de données manquantes pour chaque colonne des données
<code>fixtures_df</code> en utilisant la méthode <code>.mean</code>.
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">SOLUTION</span>
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">--------</span>
idx_na_df.mean(axis=0)
</pre>
</div></li>
</ol>

<p>
<b>Notes :</b> 
Le traitement des données manquantes est toujours un sujet délicat pour lequel il n'y a pas de
réponse unique. De nombreux facteurs interviennent dans le choix de la stratégie à appliquer. Sans
être exhaustif, nous pouvons nous poser les questions suivantes :
</p>
<ul class="org-ul">
<li>Y a-t-il des colonnes pour lesquelles les données sont largement manquantes. On peut dans ce cas
se poser la question de la suppression de ces données.</li>
<li>L'absence de données est-il très ponctuel ? La question de la suppression de ces données peut
également se poser dans ce cas.</li>
<li>Quand il s'agit de traiter des séries temporelles, il peut être intéressant de renseigner les
données manquantes par interpolation.</li>
<li>Lorsque les données manquantes dépendent de la valeur d'autres colonnes, il existe des techniques
plus avancées pour reconstruire les données partiellement ou non observées, cf. utilisation de
l'<a href="https://fr.wikipedia.org/wiki/Algorithme_esp%C3%A9rance-maximisation">algorithme EM</a>.</li>
</ul>
</div>
</div>


<div id="outline-container-orgf73ffb0" class="outline-2">
<h2 id="orgf73ffb0"><span class="section-number-2">7.</span> Premières analyses descriptives</h2>
<div class="outline-text-2" id="text-7">
<p>
Dans cette section, nous allons réaliser quelques analyses descriptives basiques permettant
d'aborder les fonctionnalités statistiques de <code>Pandas</code>.
</p>

<p>
<b>Travail à réaliser :</b>
</p>
<ol class="org-ol">
<li><p>
Calculons dans un premier temps le score moyen à la mi-temps et à la fin du match des équipes à domicile et à
l'extérieur, tout championnat confondu :
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">res_match_df</span> = fixtures_df.loc[:, [<span style="color: #CC9393;">"HTHG"</span>, <span style="color: #CC9393;">"HTAG"</span>, <span style="color: #CC9393;">"FTHG"</span>, <span style="color: #CC9393;">"FTAG"</span>]]
res_match_df.mean()
</pre>
</div></li>

<li><p>
Il est également possible de réaliser des traitements par sous-groupes de données en utilisant la
méthode <code>.groupby</code>. Par exemple, pour calculer le nombre moyen de buts marqués à la fin d'un
match par l'équipe à domicile et l'équipe à
l'extérieur sur chacun des championnats, on écrit :
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Regroupement des donn&#233;es par championnat</span>
<span style="color: #DFAF8F;">fixtures_league_id_grp</span> = fixtures_df.groupby([<span style="color: #CC9393;">"league_id"</span>])
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Calcule des scores moyens</span>
fixtures_league_id_grp[<span style="color: #CC9393;">"FTHG"</span>, <span style="color: #CC9393;">"FTAG"</span>].mean()
</pre>
</div>
<p>
Le fonctionnement de la méthode <code>.groupby</code> est donc le suivant :
</p>
<ul class="org-ul">
<li>on indique en argument du <code>.groupby</code> la liste des variables permettant de construire les
groupes (ici <code>["league_id"]</code>) ;</li>
<li>on obtient un objet de type <code>DataFrameGroupBy</code> sur lequel on va préciser les colonnes que l'on
souhaite traiter (ici <code>"FTHG"</code> et <code>"FTAG"</code>) et l'opération à réaliser (ici <code>mean</code>).</li>
</ul></li>

<li><p>
Calculer le nombre moyen de buts marqués à la fin d'un match par l'équipe à domicile et l'équipe
à l'extérieur pour chacun des championnats et chacune des saisons.  
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">SOLUTION</span>
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">--------</span>
fixtures_df.groupby([<span style="color: #CC9393;">"league_id"</span>, <span style="color: #CC9393;">"season_id"</span>])[<span style="color: #CC9393;">"FTHG"</span>, <span style="color: #CC9393;">"FTAG"</span>].mean()
</pre>
</div></li>

<li><p>
Ajouter au <code>DataFrame</code> <code>fixtures_df</code> une nouvelle colonne <code>FTG</code> (<i>Full Time Goals</i>) donnant le nombre total de buts marqués
pendant chaque rencontre :
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">SOLUTION</span>
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">--------</span>
<span style="color: #DFAF8F;">fixtures_df</span>[<span style="color: #CC9393;">"FTG"</span>] = fixtures_df[[<span style="color: #CC9393;">"FTHG"</span>, <span style="color: #CC9393;">"FTAG"</span>]].<span style="color: #DCDCCC; font-weight: bold;">sum</span>(axis=1)
</pre>
</div></li>

<li><p>
Identifier les rencontres au cours desquelles il y a eu le plus de buts inscrits.
<b>Aide</b> : Utiliser la méthode <code>.max</code>.
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">SOLUTION</span>
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">--------</span>
<span style="color: #DFAF8F;">max_ftg</span> = fixtures_df[<span style="color: #CC9393;">"FTG"</span>].<span style="color: #DCDCCC; font-weight: bold;">max</span>()
<span style="color: #DFAF8F;">idx_max</span> = fixtures_df[<span style="color: #CC9393;">"FTG"</span>] == max_ftg
fixtures_df.loc[idx_max]
</pre>
</div></li>

<li><p>
Trier les rencontres en fonction du nombre de buts inscrits. <b>Aide</b> : Utiliser la méthode
<code>.sort_values</code>.
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">SOLUTION</span>
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">--------</span>
fixtures_df.sort_values(by=<span style="color: #CC9393;">"FTG"</span>)
</pre>
</div></li>

<li><p>
Calculer la proportion des différents résultats d'un match (<code>H</code>, <code>A</code>, <code>D</code>) pour :
</p>
<ul class="org-ul">
<li>toutes les données ;</li>
<li>chacun des championnats ;</li>
<li>chacune des saisons ;</li>
<li>chacun des championnats et chacune des saisons.</li>
</ul>
<p>
<span class="underline">Aide</span> : Utiliser la méthode <code>.value_counts</code> pour le calcul des proportions (regardez l'aide)
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">SOLUTION</span>
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">--------</span>
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Proportion des r&#233;sultats sur tous les matchs</span>
fixtures_df[<span style="color: #CC9393;">"FTR"</span>].value_counts(normalize=<span style="color: #BFEBBF;">True</span>)
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Proportion des r&#233;sultats pour chaque championnat</span>
fixtures_df.groupby([<span style="color: #CC9393;">"league_id"</span>])[<span style="color: #CC9393;">"FTR"</span>].value_counts(normalize=<span style="color: #BFEBBF;">True</span>)
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Proportion des r&#233;sultats pour chaque saison</span>
fixtures_df.groupby([<span style="color: #CC9393;">"season_id"</span>])[<span style="color: #CC9393;">"FTR"</span>].value_counts(normalize=<span style="color: #BFEBBF;">True</span>)
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Proportion des r&#233;sultats pour chaque championnat et chaque saison</span>
fixtures_df.groupby([<span style="color: #CC9393;">"league_id"</span>, <span style="color: #CC9393;">"season_id"</span>])[<span style="color: #CC9393;">"FTR"</span>]\
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>  .value_counts(normalize=<span style="color: #BFEBBF;">True</span>)
</pre>
</div></li>

<li><p>
Les résultats d'un <code>groupby</code> sont indexés sur les combinaisons de modalités
prises par les variables de regroupement. Par conséquent, quand il y a plus d'une variable dans
le <code>groupby</code>, le résultat possède un index multiple. Dans le cas, d'un <code>groupby</code> couplé avec un
<code>value_counts</code>, la variable comptée (celle entre crochets) est ajoutée à l'index. Pour des
raisons de présentation des résultats, il peut être intéressant de restructurer ce résultat en
transférant la variable comptée de l'index en colonne. Pour ce faire, il faut utiliser la méthode
<code>.unstack</code> de la manière suivante :
</p>
<div class="org-src-container">
<pre class="src src-python">fixtures_df.groupby([<span style="color: #CC9393;">"league_id"</span>, <span style="color: #CC9393;">"season_id"</span>])[<span style="color: #CC9393;">"FTR"</span>]\
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>  .value_counts(normalize=<span style="color: #BFEBBF;">True</span>)\
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>  .unstack()
</pre>
</div></li>

<li><p>
Déterminer le championnat où il y a le plus de tirs cadrés en moyenne. <b>Aide</b> : Utiliser la
méthode <code>.idxmax</code>.
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">SOLUTION</span>
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">--------</span>
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Calcul de la somme des tirs cadr&#233;s par match</span>
<span style="color: #DFAF8F;">fixtures_df</span>[<span style="color: #CC9393;">"ST"</span>] = fixtures_df[[<span style="color: #CC9393;">"HST"</span>, <span style="color: #CC9393;">"AST"</span>]].<span style="color: #DCDCCC; font-weight: bold;">sum</span>(axis=1)
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Calcul du championnat avec le plus de tirs cadr&#233;s moyen</span>
fixtures_df.groupby([<span style="color: #CC9393;">"league_id"</span>])[<span style="color: #CC9393;">"ST"</span>].mean().idxmax()
</pre>
</div></li>

<li><p>
Déterminer le championnat et la saison où il y a la proportion de victoire à domicile la plus
faible. <b>Aide</b> : Utiliser la méthode <code>.idxmin</code>.
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">SOLUTION</span>
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">--------</span>
<span style="color: #DFAF8F;">ftr_prop_df</span> = fixtures_df.groupby([<span style="color: #CC9393;">"league_id"</span>, <span style="color: #CC9393;">"season_id"</span>])[<span style="color: #CC9393;">"FTR"</span>]\
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>.value_counts(normalize=<span style="color: #BFEBBF;">True</span>)\
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>.unstack()
ftr_prop_df.loc[:, <span style="color: #CC9393;">"H"</span>].idxmin()
</pre>
</div></li>
</ol>
</div>
</div>
</div>
</body>
</html>
