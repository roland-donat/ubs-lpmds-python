<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="fr" xml:lang="fr">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Data management et premières analyses descriptives avec =Pandas=</title>
<meta name="author" content="Roland Donat" />
<meta name="generator" content="Org Mode" />
<link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/css/htmlize.css"/>
<link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/css/readtheorg.css"/>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/lib/js/jquery.stickytableheaders.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/js/readtheorg.js"></script>
<link rel="stylesheet" type="text/css" href="https://roland-donat.github.io/ubs/Charte_graphique/IUT/ubs_iut_vannes.css" />
<link rel="stylesheet" type="text/css" href="https://roland-donat.github.io/ubs-lpmds-python/custom.css" />
</head>
<body>
<div id="content" class="content">
<h1 class="title">Data management et premières analyses descriptives avec <code>Pandas</code></h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table des matières</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#orgfcbd1fb">1. Contexte et objectif</a></li>
<li><a href="#orgd6cd5d8">2. Données historiques</a>
<ul>
<li><a href="#org9b54d7b">2.1. Présentation des données</a></li>
<li><a href="#org9446533">2.2. Chargement des données</a></li>
</ul>
</li>
<li><a href="#org5baec85">3. Notions de <code>DataFrame</code> et <code>Series</code></a></li>
<li><a href="#orgc706fcc">4. Sélection des données</a></li>
<li><a href="#org2e66dc6">5. Typage des données</a></li>
<li><a href="#orgf8cd8e2">6. Traitement des données manquantes</a></li>
<li><a href="#orgece9ddd">7. Premières analyses descriptives</a></li>
</ul>
</div>
</div>






<div id="orgf2fce45" class="figure">
<p><img src="https://www.agent-x.com.au/wp-content/uploads/2011/06/Perfect-Programmer-dfe194b-e8d3b11-b960bd5.jpg" alt="Perfect-Programmer-dfe194b-e8d3b11-b960bd5.jpg" />
</p>
</div>


<div id="outline-container-orgfcbd1fb" class="outline-2">
<h2 id="orgfcbd1fb"><span class="section-number-2">1.</span> Contexte et objectif</h2>
<div class="outline-text-2" id="text-1">
<p>
Quelle est la probabilité pour Lorient de vaincre Paris en Ligue 1 compte tenu des joueurs prévus
pour la rencontre ? Une star est blessée, quel impact cela aura t-il sur la probabilité de victoire
de votre équipe préférée ?    
</p>

<p>
L'industrie du sport est un secteur saturé de statistiques et de données. Pourtant, la
généralisation de l'utilisation de la <i>data science</i> pour l'analyse sportive est une pratique
relativement récente. 
</p>

<p>
Dans ce TD et les suivants, nous allons commencer le développement d'un algorithme de pronostics pour les matchs de football. Ce travail repose sur l'exploitation de données historiques 
de différents championnats européens ainsi que sur les cotes proposées par quelques
bookmakers. Le développement complet d'un tel outil nécessite la réalisation des tâches suivantes :
</p>
<ol class="org-ol">
<li>Préparation des données et premières analyses exploratoires.</li>
<li>Analyse descriptive et visualisation.</li>
<li>Construction d'indicateurs.</li>
<li>Modélisation prévisionnelle et évaluation des performances.</li>
</ol>

<p>
Ce TD porte en particulier sur le premier point.
</p>

<p>
<b>Rappels :</b>
</p>
<ul class="org-ul">
<li>Créez un <i>notebook</i> dans le lequel vous allez écrire, exécuter et documenter votre code <code>Python</code>.</li>
<li>Prenez le temps de bien présenter et bien rédiger votre <i>notebook</i>.</li>
</ul>
</div>
</div>


<div id="outline-container-orgd6cd5d8" class="outline-2">
<h2 id="orgd6cd5d8"><span class="section-number-2">2.</span> Données historiques</h2>
<div class="outline-text-2" id="text-2">
</div>
<div id="outline-container-org9b54d7b" class="outline-3">
<h3 id="org9b54d7b"><span class="section-number-3">2.1.</span> Présentation des données</h3>
<div class="outline-text-3" id="text-2-1">
<p>
Les données historiques, référencées dans la suite par données <code>fixtures</code>, contiennent un historique
 de matchs sur différents championnats. Le Tableau <a href="#org2c4831c">1</a> présente
 une description succintes des variables présentes.
</p>

<table id="org2c4831c" border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Tableau 1 :</span> Définition des variables du jeu de données <code>fixtures</code>.</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Colonne</th>
<th scope="col" class="org-left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">league_id</td>
<td class="org-left">Identifiant du championnat</td>
</tr>

<tr>
<td class="org-left">season_id</td>
<td class="org-left">Identifiant de la saison</td>
</tr>

<tr>
<td class="org-left">Date</td>
<td class="org-left">Date du match au format %Y-%m-%d</td>
</tr>

<tr>
<td class="org-left">HomeTeam</td>
<td class="org-left">Équipe à domicile (ED)</td>
</tr>

<tr>
<td class="org-left">AwayTeam</td>
<td class="org-left">Équipe à l'exterieur (EE)</td>
</tr>

<tr>
<td class="org-left">FTHG</td>
<td class="org-left">Nombre de buts de l'ED à la fin du match</td>
</tr>

<tr>
<td class="org-left">FTAG</td>
<td class="org-left">Nombre de buts de l'EE à la fin du match</td>
</tr>

<tr>
<td class="org-left">FTR</td>
<td class="org-left">Résultat à la fin du match (H = ED gagne, D = match nul, A = EE gagne)</td>
</tr>

<tr>
<td class="org-left">HTHG</td>
<td class="org-left">Nombre de buts de l'ED à la mi-temps</td>
</tr>

<tr>
<td class="org-left">HTAG</td>
<td class="org-left">Nombre de buts de l'EE à la mi-temps</td>
</tr>

<tr>
<td class="org-left">HTR</td>
<td class="org-left">Résultat à la mi-temps (H = ED gagne, D = match nul, A = EE gagne)</td>
</tr>

<tr>
<td class="org-left">HS</td>
<td class="org-left">Nombre de tirs tentés par l'ED</td>
</tr>

<tr>
<td class="org-left">AS</td>
<td class="org-left">Nombre de tirs tentés par l'EE</td>
</tr>

<tr>
<td class="org-left">HST</td>
<td class="org-left">Nombre de tirs cadrés par l'ED</td>
</tr>

<tr>
<td class="org-left">AST</td>
<td class="org-left">Nombre de tirs cadrés par l'EE</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="outline-container-org9446533" class="outline-3">
<h3 id="org9446533"><span class="section-number-3">2.2.</span> Chargement des données</h3>
<div class="outline-text-3" id="text-2-2">
<p>
Nous allons tout d'abord charger les données <code>fixtures</code> dans notre environnement
<code>Python</code> en utilisant la librairie <code>Pandas</code>.
Ces données sont accessibles <i>via</i> les liens suivants :
</p>


<p>
<b>Travail à réaliser :</b>
</p>
<ol class="org-ol">
<li><p>
Importer la librairie <code>pandas</code> dans votre environnement.
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">import</span> pandas <span style="color: #F0DFAF; font-weight: bold;">as</span> pd
</pre>
</div></li>

<li><p>
Afficher la version de la librairie <code>pandas</code> utilisée.
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">print</span>(f<span style="color: #CC9393;">"Pandas : {pd.__version__}"</span>)
</pre>
</div></li>

<li><p>
Utiliser la méthode <code>Pandas</code> <code>.read_csv</code> afin de lire les données directement depuis ce lien :
<a href="https://roland-donat.github.io/ubs-lpmds-python/td/data/fixtures.csv.bz2">https://roland-donat.github.io/ubs-lpmds-python/td/data/fixtures.csv.bz2</a>
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">fixtures_url</span> = <span style="color: #CC9393;">"https://roland-donat.github.io/ubs-lpmds-python/td/data/fixtures.csv.bz2"</span>
<span style="color: #DFAF8F;">fixtures_df</span> = pd.read_csv(fixtures_url, sep=<span style="color: #CC9393;">";"</span>, compression=<span style="color: #CC9393;">"bz2"</span>)
</pre>
</div>
<p>
Note : Les données sont sépérées par des points-virgules et compressées en <code>bzip2</code>. Il faut donc penser
à utiliser les arguments <code>sep</code> et <code>compression</code> afin de tenir compte de ces deux éléments.
</p></li>

<li><p>
Utiliser les méthodes <code>.head</code>, <code>.info</code> et <code>.describe</code> afin d'avoir un aperçu des données chargées.
</p>
<div class="org-src-container">
<pre class="src src-python">fixtures_df.head()
</pre>
</div>
<div class="org-src-container">
<pre class="src src-python">fixtures_df.info()
</pre>
</div>
<div class="org-src-container">
<pre class="src src-python">fixtures_df.describe()
</pre>
</div></li>
</ol>
</div>
</div>
</div>


<div id="outline-container-org5baec85" class="outline-2">
<h2 id="org5baec85"><span class="section-number-2">3.</span> Notions de <code>DataFrame</code> et <code>Series</code></h2>
<div class="outline-text-2" id="text-3">
<p>
La librairie <code>Pandas</code> travaille principalement avec deux types d'objets :
</p>
<ul class="org-ul">
<li>les tableaux de données appelés <code>DataFrame</code> ;</li>
<li>les vecteurs de données appelés <code>Series</code>.</li>
</ul>

<p>
Un <code>DataFrame</code> est composé :
</p>
<ul class="org-ul">
<li>d'une ou plusieurs colonnes représentant les variables du jeu de données ;</li>
<li>d'une ou plusieurs lignes représentant les individus du jeu de données.</li>
</ul>

<p>
Chaque ligne et chaque colonne d'un <code>DataFrame</code> est donc un vecteur (une seule dimension) mis sous la
forme d'une <code>Series</code>.
</p>


<p>
<b>Travail à réaliser :</b>
</p>
<ol class="org-ol">
<li><p>
Quel est le type de la variable <code>fixtures_df</code> ?
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DCDCCC; font-weight: bold;">type</span>(fixtures_df)
</pre>
</div></li>

<li><p>
Dans un <code>DataFrame</code>, chaque valeur est identifiée grâce à un nom de ligne (appelé <code>index</code>) et
un nom de colonne (appelé <code>column</code>). Afficher le nom des lignes et le nom des colonnes des
données <code>fixtures</code> :
</p>
<div class="org-src-container">
<pre class="src src-python">fixtures_df.index
</pre>
</div>
<div class="org-src-container">
<pre class="src src-python">fixtures_df.columns
</pre>
</div></li>

<li><p>
Vous pouvez accéder aux différents éléments d'un <code>DataFrame</code> en utilisant l'attribut <code>.loc</code>. Par
exemple, pour récupérer la colonne <code>HomeTeam</code> :
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">&#201;criture explicite</span>
fixtures_df.loc[:, <span style="color: #CC9393;">"HomeTeam"</span>]
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">&#201;criture implicite</span>
fixtures_df[<span style="color: #CC9393;">"HomeTeam"</span>]
</pre>
</div>
<p>
La commande précédente permet de récupérer toutes les lignes (opérateur <code>:</code>) de la colonne
appelée <code>"HomeTeam"</code>. 
</p>

<p>
De la même manière, on peut accéder à la ligne de label <code>3</code> comme suit :
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">&#201;criture explicite</span>
fixtures_df.loc[3, :]
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">&#201;criture implicite</span>
fixtures_df.loc[3]
</pre>
</div>

<p>
Enfin, vous pouvez accéder à plusieurs lignes et colonnes (sous-tableau) en utilisant des listes
dans l'attribut <code>.loc</code> :
</p>
<div class="org-src-container">
<pre class="src src-python">fixtures_df.loc[3:7, [<span style="color: #CC9393;">"HomeTeam"</span>, <span style="color: #CC9393;">"AwayTeam"</span>]]
</pre>
</div></li>

<li>Sélectionner les 50 premiers matchs en prenant les colonnes du championnat, de la saison, de la
date, des équipes et du score final.</li>
<li>Quel est le type des objets suivants <code>fixtures_df.loc[:, "league_id"]</code> et
<code>fixtures_df.loc[3]</code> ?</li>
<li>Quelles sont les principales caractéristiques d'un objet de type <code>Series</code> ?</li>
<li><p>
Il est possible de changer l'index d'un <code>DataFrame</code> avec la méthode <code>set_index</code>. Par exemple, on
peut créer un nouveau <code>DataFrame</code> dans lequel les colonnes <code>"HomeTeam"</code> et <code>"AwayTeam"</code> sont
utilisées en tant qu'index :
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">fixtures_2_df</span> = fixtures_df.set_index([<span style="color: #CC9393;">"HomeTeam"</span>, <span style="color: #CC9393;">"AwayTeam"</span>])
<span style="color: #F0DFAF; font-weight: bold;">print</span>(fixtures_2_df)
</pre>
</div>
<p>
On obtient ainsi un index multidimensionnel. Les lignes du <code>DataFrame</code> <code>fixtures_bis_df</code> sont maintenant
identifiées par la valeur d'une équipe à domicile et une équipe à l'extérieure :
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">print</span>(fixtures_2_df.loc[(<span style="color: #CC9393;">"Rennes"</span>, <span style="color: #CC9393;">"Lorient"</span>), :])
</pre>
</div></li>

<li>Créer un nouveau <code>DataFrame</code>, nommé <code>fixtures_3_df</code>, indexé par les colonnes <code>["league_id", "season_id", "Date",
   "HomeTeam", "AwayTeam"]</code>. Quelle est la particularité de cette indexation ?</li>
<li><p>
Vous pouvez revenir à l'indexation par défaut, c'est à dire une numérotation des lignes à partir
de 0 avec la méthode <code>.reset_index</code> :
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">print</span>(fixtures_3_df.reset_index())
</pre>
</div></li>
</ol>
</div>
</div>

<div id="outline-container-orgc706fcc" class="outline-2">
<h2 id="orgc706fcc"><span class="section-number-2">4.</span> Sélection des données</h2>
<div class="outline-text-2" id="text-4">
<p>
Au cours de vos analyses, vous ressentirez probablement vite le besoin de filtrer les données
en fonction des valeurs prises par certaines colonnes. Pour ce faire, il suffit d'utiliser les
opérateurs de comparaison <code>Python</code> appliqués aux colonnes d'un <code>DataFrame</code>. 
</p>

<p>
<b>Travail à réaliser :</b>
</p>
<ol class="org-ol">
<li><p>
Nous allons commencer par récupérer tous les matchs joués à l'extérieur par l'équipe de
Lorient. Pour ce faire il faut dans un premier temps créer une <code>Series</code> booléenne (c'est-à-dire
dont les valeurs sont <code>True</code> ou <code>False</code>) permettant de repérer les matchs qui nous intéressent :
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">condition</span> = fixtures_df[<span style="color: #CC9393;">"AwayTeam"</span>] == <span style="color: #CC9393;">"Lorient"</span>
</pre>
</div>
<p>
La <code>Serie</code> <code>condition</code> contient la valeur <code>True</code> lorsque la colonne <code>"AwayTeam"</code>
vaut <code>"Lorient"</code> et <code>False</code> sinon.
</p>

<p>
Il suffit ensuite d'utiliser cette <code>Series</code> afin de récupérer les lignes du <code>DataFrame</code>
<code>fixtures_df</code> pour lesquelles la condition est vraie. Deux syntaxes sont possibles. Une
syntaxe explicite (recommandée) utilise l'attribut <code>.loc</code> :
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">fixtures_lorient_df</span> = fixtures_df.loc[condition]
<span style="color: #F0DFAF; font-weight: bold;">print</span>(fixtures_lorient_df)
</pre>
</div>
<p>
Et une syntaxe implicite équivalente :
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">fixtures_lorient_bis_df</span> = fixtures_df[condition]
<span style="color: #F0DFAF; font-weight: bold;">print</span>(fixtures_lorient_bis_df)
</pre>
</div></li>

<li>Extraire les matchs au cours desquels l'équipe à domicile a réussi au moins 20 tirs cadrés
(colonne <code>HST</code>) en utilisant l'opérateur <code>&gt;=</code>.</li>
<li><p>
Il est possible de construire des conditions plus complexes en utilisant les opérateurs booléens
de <code>Pandas</code> : <code>&amp;</code> (ET logique) <code>|</code> (OU logique) et <code>~</code> (NON logique). Par exemple, nous pouvons obtenir les
matchs au cours desquels l'équipe à domicile mène à la mi-temps et perd à la fin du match :
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">condition_mi_temps</span> = fixtures_df[<span style="color: #CC9393;">"HTR"</span>] == <span style="color: #CC9393;">"H"</span>
<span style="color: #DFAF8F;">condition_fin</span> = fixtures_df[<span style="color: #CC9393;">"FTR"</span>] == <span style="color: #CC9393;">"A"</span>
<span style="color: #F0DFAF; font-weight: bold;">print</span>(fixtures_df.loc[condition_mi_temps &amp; condition_fin])
</pre>
</div></li>

<li>Extraire les matchs perdus à domicile par les joueurs de Lorient alors qu'ils ont réussi
strictement plus de tirs cadrés que leur adversaire.</li>
<li>Extraire à présent <b>tous les matchs</b> perdus par les joueurs de Lorient alors qu'ils ont réussi
strictement plus de tirs cadrés que leur adversaire.</li>
<li><p>
Pour éviter d'enchaîner les opérateurs OU quand il s'agit d'un filtrage sur les valeurs d'une
même colonne, il est commode d'utiliser la méthode pour les <code>Series</code> nommée <code>.isin</code> qui va tester
si chaque donnée de la <code>Series</code> se trouve dans la liste de valeurs passée en argument de la
méthode.
</p>

<p>
Par exemple, le code suivant récupère les matchs des championnats de France :
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">condition</span> = fixtures_df[<span style="color: #CC9393;">"league_id"</span>].isin([<span style="color: #CC9393;">"fra_l2"</span>, <span style="color: #CC9393;">"fra_l1"</span>])
<span style="color: #F0DFAF; font-weight: bold;">print</span>(fixtures_df.loc[condition])
</pre>
</div></li>

<li>Extraire les matchs qui ne concernent pas un championnat français.</li>
</ol>
</div>
</div>
<div id="outline-container-org2e66dc6" class="outline-2">
<h2 id="org2e66dc6"><span class="section-number-2">5.</span> Typage des données</h2>
<div class="outline-text-2" id="text-5">
<p>
Afin de faciliter le traitement ultérieur des données, il convient de s'assurer que chaque colonne
soit correctement typée. Les principaux types de données reconnus par <code>Pandas</code> sont les entiers (<code>int</code>), les
nombres réels (<code>float</code>), les dates (<code>date</code> ou <code>datetime64</code>), les données qualitatives (<code>category</code>) et
les chaînes de caractères (<code>object</code>).
</p>

<p>
<b>Travail à réaliser :</b>
</p>
<ol class="org-ol">
<li><p>
La variable <code>league_id</code> ne prend qu'un nombre fini de valeurs, c'est donc une variable
qualitative. Il convient de lui assigner le type <code>category</code> comme suit :
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">fixtures_df</span>[<span style="color: #CC9393;">"league_id"</span>] = fixtures_df[<span style="color: #CC9393;">"league_id"</span>].astype(<span style="color: #CC9393;">"category"</span>)
</pre>
</div>
<p>
Une variable de type <code>category</code> dispose d'un attribut spécial <code>.cat</code> apportant, entre autres, des
fonctionnalités telles que :
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Num&#233;risation des modalit&#233;s</span>
<span style="color: #F0DFAF; font-weight: bold;">print</span>(fixtures_df[<span style="color: #CC9393;">"league_id"</span>].cat.codes)
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">R&#233;cup&#233;ration de la liste des modalit&#233;s</span>
<span style="color: #F0DFAF; font-weight: bold;">print</span>(fixtures_df[<span style="color: #CC9393;">"league_id"</span>].cat.categories)
</pre>
</div></li>

<li>Transformer les autres variables qualitatives en <code>category</code>.</li>
<li><p>
Lorsque les modalités sont des labels textuels, les colonnes de type <code>category</code> ont également
accès à l'attribut <code>.str</code> permettant de manipuler les chaînes de caractères. Cet attribut est
également disponible sur les variables de type <code>object</code>. L'attribut <code>.str</code> donne accès à la
plupart des fonctionnalités de traitement des chaînes offertes par <code>Python</code>, e.g. <code>strip</code>,
<code>lower</code>, <code>upper</code>, <code>find</code>, <code>len</code>, etc. Exemple :
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">print</span>(fixtures_df[<span style="color: #CC9393;">"league_id"</span>].<span style="color: #DCDCCC; font-weight: bold;">str</span>.upper())
<span style="color: #F0DFAF; font-weight: bold;">print</span>(fixtures_df[<span style="color: #CC9393;">"league_id"</span>].<span style="color: #DCDCCC; font-weight: bold;">str</span>.split(<span style="color: #CC9393;">"_"</span>))
<span style="color: #F0DFAF; font-weight: bold;">print</span>(fixtures_df[<span style="color: #CC9393;">"league_id"</span>].<span style="color: #DCDCCC; font-weight: bold;">str</span>.split(<span style="color: #CC9393;">"_"</span>, expand=<span style="color: #BFEBBF;">True</span>))
</pre>
</div></li>

<li>Utiliser la méthode <code>.str.startswith</code> afin d'identifier les matchs des championnats français (à
savoir <code>fra_l1</code> ou <code>fra_l2</code>) et les stocker dans un nouveau <code>DataFrame</code> <code>fixtures_fra_df</code>.</li>
<li><p>
Convertir la colonne <code>Date</code> avec le type <code>"datetime64"</code>.
Les colonnes de type <code>datetime64</code> possèdent un attribut <code>dt</code> apportant des fonctionnalités
permettant de manipuler les dates. Vous pouvez, entre autres, extraire le jour, le mois ou l'année
d'une date :
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">print</span>(fixtures_df[<span style="color: #CC9393;">"Date"</span>].dt.day)
<span style="color: #F0DFAF; font-weight: bold;">print</span>(fixtures_df[<span style="color: #CC9393;">"Date"</span>].dt.month)
<span style="color: #F0DFAF; font-weight: bold;">print</span>(fixtures_df[<span style="color: #CC9393;">"Date"</span>].dt.year)
</pre>
</div></li>

<li>Identifier les matchs des championnats français ayant eu lieu en 2010 et les stocker dans un nouveau <code>DataFrame</code> <code>fixtures_fra_2010_df</code>.</li>
</ol>
</div>
</div>
<div id="outline-container-orgf8cd8e2" class="outline-2">
<h2 id="orgf8cd8e2"><span class="section-number-2">6.</span> Traitement des données manquantes</h2>
<div class="outline-text-2" id="text-6">
<p>
Les données manquantes dans les <code>DataFrame</code> et les <code>Series</code> sont représentées par le terme <code>NaN</code>
(<i>Not a Number</i>) ou <code>NaT</code> (<i>Not a Time</i>).
</p>

<p>
<b>Travail à réaliser :</b>
</p>
<ol class="org-ol">
<li><p>
Les <code>DataFrame</code> et les <code>Series</code> dispose de la méthode <code>.isnull</code> permettant de repérer les données
manquantes. Le code suivant construit un <code>DataFrame</code> booléen ayant pour valeur <code>True</code> si
l'élément correspondant dans le <code>DataFrame</code> <code>fixtures_df</code> est manquant et <code>False</code> sinon :
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">idx_na_df</span> = fixtures_df.isnull()
<span style="color: #F0DFAF; font-weight: bold;">print</span>(idx_na_df)
</pre>
</div>

<p>
À partir de ce résultat brut, nous pouvons déduire par exemple le nombre de valeurs manquantes
par colonne avec la méthode <code>.sum</code> :
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">print</span>(idx_na_df.<span style="color: #DCDCCC; font-weight: bold;">sum</span>(axis=0))
</pre>
</div>

<p>
<b>Note 1</b> : L'utilisation de l'argument <code>axis</code> dans la méthode <code>.sum</code> permet d'indiquer sur quelle
dimension est réalisée l'opération de sommation. En indiquant <code>axis=0</code>, cela signifie que les
valeurs du <code>DataFrame</code> sont sommées le long des lignes (<code>index</code>). Avec <code>axis=1</code>, la sommation sera
réalisée le long des colonnes (<code>columns</code>) et donnera donc le nombre de valeurs manquantes de chaque ligne.
</p>

<p>
<b>Note 2</b> : L'argument <code>axis</code> est présent dans de nombreuses méthodes pour <code>DataFrame</code> et
<code>Series</code>. Le mode de fonctionnement est toujours le même : <code>axis=0</code> signifie que l'opération
considérée est faite sur les lignes (<code>index</code>) et <code>axis=1</code> sur les colonnes (<code>columns</code>).
</p>

<p>
<b>Note 3</b> : Lorsque des opérations numériques sur des booléens sont réalisées, <code>Pandas</code> remplace
la valeur <code>True</code> par 1 et la valeur <code>False</code> par 0.
</p></li>

<li>Calculer à présent la proportion de données manquantes pour chaque colonne des données
<code>fixtures_df</code> en utilisant la méthode <code>.mean</code>.</li>
</ol>
<p>
<b>Notes :</b> 
Le traitement des données manquantes est toujours un sujet délicat pour lequel il n'y a pas de
réponse unique. De nombreux facteurs interviennent dans le choix de la stratégie à appliquer. Sans
être exhaustif, nous pouvons nous poser les questions suivantes :
</p>
<ul class="org-ul">
<li>Y a-t-il des colonnes pour lesquelles les données sont largement manquantes. On peut dans ce cas
se poser la question de la suppression de ces données.</li>
<li>L'absence de données est-il très ponctuel ? La question de la suppression de ces données peut
également se poser dans ce cas.</li>
<li>Quand il s'agit de traiter des séries temporelles, il peut être intéressant de renseigner les
données manquantes par interpolation.</li>
<li>Lorsque les données manquantes dépendent de la valeur d'autres colonnes, il existe des techniques
plus avancées pour reconstruire les données partiellement ou non observées, cf. utilisation de
l'<a href="https://fr.wikipedia.org/wiki/Algorithme_esp%C3%A9rance-maximisation">algorithme EM</a>.</li>
</ul>
</div>
</div>


<div id="outline-container-orgece9ddd" class="outline-2">
<h2 id="orgece9ddd"><span class="section-number-2">7.</span> Premières analyses descriptives</h2>
<div class="outline-text-2" id="text-7">
<p>
Dans cette section, nous allons réaliser quelques analyses descriptives basiques permettant
d'aborder les fonctionnalités statistiques de <code>Pandas</code>.
</p>

<p>
<b>Travail à réaliser :</b>
</p>
<ol class="org-ol">
<li><p>
Calculons dans un premier temps le score moyen à la mi-temps et à la fin du match des équipes à domicile et à
l'extérieur, tout championnat confondu :
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">res_match_df</span> = fixtures_df.loc[:, [<span style="color: #CC9393;">"HTHG"</span>, <span style="color: #CC9393;">"HTAG"</span>, <span style="color: #CC9393;">"FTHG"</span>, <span style="color: #CC9393;">"FTAG"</span>]]
<span style="color: #F0DFAF; font-weight: bold;">print</span>(res_match_df.mean())
</pre>
</div></li>

<li><p>
Il est également possible de réaliser des traitements par sous-groupes de données en utilisant la
méthode <code>.groupby</code>. Par exemple, pour calculer le score moyen à la fin du match des équipes à domicile et à
l'extérieur sur chacun des championnats, on écrit :
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Regroupement des donn&#233;es par championnat</span>
<span style="color: #DFAF8F;">fixtures_league_id_grp</span> = fixtures_df.groupby([<span style="color: #CC9393;">"league_id"</span>])
<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Calcule des scores moyens</span>
<span style="color: #F0DFAF; font-weight: bold;">print</span>(fixtures_league_id_grp[<span style="color: #CC9393;">"FTHG"</span>, <span style="color: #CC9393;">"FTAG"</span>].mean())
</pre>
</div>
<p>
Le fonctionnement de la méthode <code>.groupby</code> est donc le suivant :
</p>
<ul class="org-ul">
<li>on indique en argument du <code>.groupby</code> la liste des variables permettant de construire les
groupes (ici <code>["league_id"]</code>) ;</li>
<li>on obtient un objet de type <code>DataFrameGroupBy</code> sur lequel on va préciser les colonnes que l'on
souhaite traiter (ici <code>"FTHG"</code> et <code>"FTAG"</code>) et l'opération à réaliser (ici <code>mean</code>).</li>
</ul></li>

<li>Calculer le score moyen à la fin du match des équipes à domicile et à l'extérieur sur chacun des
championnats et chacune des saisons.</li>

<li><p>
Ajoutons au <code>DataFrame</code> <code>fixtures_df</code> une nouvelle colonne <code>FTG</code> (<i>Full Time Goals</i>) donnant le nombre total de buts marqués
pendant chaque rencontre :
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">fixtures_df</span>[<span style="color: #CC9393;">"FTG"</span>] = fixtures_df[[<span style="color: #CC9393;">"FTHG"</span>, <span style="color: #CC9393;">"FTAG"</span>]].<span style="color: #DCDCCC; font-weight: bold;">sum</span>(axis=1)
fixtures_df.head()
</pre>
</div></li>

<li>Identifier les rencontres au cours desquelles il y a eu le plus de buts inscrits.
<b>Aide</b> : Utiliser la méthode <code>.max</code>.</li>

<li>Trier les rencontres en fonction du nombre de buts inscrits. <b>Aide</b> : Utiliser la méthode
<code>.sort_values</code>.</li>

<li><p>
Calculer la proportion des différents résultats d'un match (<code>H</code>, <code>A</code>, <code>D</code>) pour :
</p>
<ul class="org-ul">
<li>tout championnat confondu ;</li>
<li>chacun des championnats ;</li>
<li>chacune des saisons ;</li>
<li>chacun des championnats et chacune des saisons.</li>
</ul>
<p>
<span class="underline">Aide</span> : Utiliser la méthode <code>.value_counts</code> pour le calcul des proportions et la méthode
<code>.unstack</code> pour la présentation des chiffres.
</p></li>

<li>Déterminer le championnat où il y a :
<ul class="org-ul">
<li>le plus de tirs cadrés ;</li>
<li>le moins de victoires à domicile.</li>
</ul></li>
</ol>
</div>
</div>
</div>
</body>
</html>
